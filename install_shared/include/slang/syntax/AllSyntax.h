//------------------------------------------------------------------------------
//! @file AllSyntax.h
//! @brief All generated syntax node data structures
//
// SPDX-FileCopyrightText: Michael Popoloski
// SPDX-License-Identifier: MIT
//------------------------------------------------------------------------------
#pragma once

#include "slang/parsing/Token.h"
#include "slang/syntax/SyntaxNode.h"
#include "slang/util/BumpAllocator.h"

// This file contains all parse tree syntax nodes.
// It is auto-generated by the syntax_gen.py script under the scripts/ directory.

namespace slang::syntax {

struct SLANG_EXPORT ExpressionSyntax : public SyntaxNode {

    ExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit ExpressionSyntax(const ExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT DataTypeSyntax : public ExpressionSyntax {

    DataTypeSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind) {
    }

    explicit DataTypeSyntax(const DataTypeSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT TimingControlSyntax : public SyntaxNode {

    TimingControlSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit TimingControlSyntax(const TimingControlSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT SequenceExprSyntax : public SyntaxNode {

    SequenceExprSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit SequenceExprSyntax(const SequenceExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT PropertyExprSyntax : public SyntaxNode {

    PropertyExprSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit PropertyExprSyntax(const PropertyExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT EqualsValueClauseSyntax : public SyntaxNode {
    Token equals;
    not_null<ExpressionSyntax*> expr;

    EqualsValueClauseSyntax(Token equals, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::EqualsValueClause), equals(equals), expr(&expr) {
        this->expr->parent = this;
    }

    explicit EqualsValueClauseSyntax(const EqualsValueClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT AttributeSpecSyntax : public SyntaxNode {
    Token name;
    EqualsValueClauseSyntax* value;

    AttributeSpecSyntax(Token name, EqualsValueClauseSyntax* value) :
        SyntaxNode(SyntaxKind::AttributeSpec), name(name), value(value) {
        if (this->value) this->value->parent = this;
    }

    explicit AttributeSpecSyntax(const AttributeSpecSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT AttributeInstanceSyntax : public SyntaxNode {
    Token openParen;
    Token openStar;
    SeparatedSyntaxList<AttributeSpecSyntax> specs;
    Token closeStar;
    Token closeParen;

    AttributeInstanceSyntax(Token openParen, Token openStar, const SeparatedSyntaxList<AttributeSpecSyntax>& specs, Token closeStar, Token closeParen) :
        SyntaxNode(SyntaxKind::AttributeInstance), openParen(openParen), openStar(openStar), specs(specs), closeStar(closeStar), closeParen(closeParen) {
        this->specs.parent = this;
        for (auto child : this->specs)
            child->parent = this;
    }

    explicit AttributeInstanceSyntax(const AttributeInstanceSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NamedLabelSyntax : public SyntaxNode {
    Token name;
    Token colon;

    NamedLabelSyntax(Token name, Token colon) :
        SyntaxNode(SyntaxKind::NamedLabel), name(name), colon(colon) {
    }

    explicit NamedLabelSyntax(const NamedLabelSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StatementSyntax : public SyntaxNode {
    NamedLabelSyntax* label;
    SyntaxList<AttributeInstanceSyntax> attributes;

    StatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes) :
        SyntaxNode(kind), label(label), attributes(attributes) {
        if (this->label) this->label->parent = this;
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
    }

    explicit StatementSyntax(const StatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT MemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    MemberSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes) :
        SyntaxNode(kind), attributes(attributes) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
    }

    explicit MemberSyntax(const MemberSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ArgumentSyntax : public SyntaxNode {

    ArgumentSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit ArgumentSyntax(const ArgumentSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT EmptyArgumentSyntax : public ArgumentSyntax {
    Token placeholder;

    EmptyArgumentSyntax(Token placeholder) :
        ArgumentSyntax(SyntaxKind::EmptyArgument), placeholder(placeholder) {
    }

    explicit EmptyArgumentSyntax(const EmptyArgumentSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT OrderedArgumentSyntax : public ArgumentSyntax {
    not_null<PropertyExprSyntax*> expr;

    OrderedArgumentSyntax(PropertyExprSyntax& expr) :
        ArgumentSyntax(SyntaxKind::OrderedArgument), expr(&expr) {
        this->expr->parent = this;
    }

    explicit OrderedArgumentSyntax(const OrderedArgumentSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NamedArgumentSyntax : public ArgumentSyntax {
    Token dot;
    Token name;
    Token openParen;
    PropertyExprSyntax* expr;
    Token closeParen;

    NamedArgumentSyntax(Token dot, Token name, Token openParen, PropertyExprSyntax* expr, Token closeParen) :
        ArgumentSyntax(SyntaxKind::NamedArgument), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
        if (this->expr) this->expr->parent = this;
    }

    explicit NamedArgumentSyntax(const NamedArgumentSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<ArgumentSyntax> parameters;
    Token closeParen;

    ArgumentListSyntax(Token openParen, const SeparatedSyntaxList<ArgumentSyntax>& parameters, Token closeParen) :
        SyntaxNode(SyntaxKind::ArgumentList), openParen(openParen), parameters(parameters), closeParen(closeParen) {
        this->parameters.parent = this;
        for (auto child : this->parameters)
            child->parent = this;
    }

    explicit ArgumentListSyntax(const ArgumentListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParamAssignmentSyntax : public SyntaxNode {

    ParamAssignmentSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit ParamAssignmentSyntax(const ParamAssignmentSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT OrderedParamAssignmentSyntax : public ParamAssignmentSyntax {
    not_null<ExpressionSyntax*> expr;

    OrderedParamAssignmentSyntax(ExpressionSyntax& expr) :
        ParamAssignmentSyntax(SyntaxKind::OrderedParamAssignment), expr(&expr) {
        this->expr->parent = this;
    }

    explicit OrderedParamAssignmentSyntax(const OrderedParamAssignmentSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NamedParamAssignmentSyntax : public ParamAssignmentSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    NamedParamAssignmentSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        ParamAssignmentSyntax(SyntaxKind::NamedParamAssignment), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
        if (this->expr) this->expr->parent = this;
    }

    explicit NamedParamAssignmentSyntax(const NamedParamAssignmentSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParameterValueAssignmentSyntax : public SyntaxNode {
    Token hash;
    Token openParen;
    SeparatedSyntaxList<ParamAssignmentSyntax> parameters;
    Token closeParen;

    ParameterValueAssignmentSyntax(Token hash, Token openParen, const SeparatedSyntaxList<ParamAssignmentSyntax>& parameters, Token closeParen) :
        SyntaxNode(SyntaxKind::ParameterValueAssignment), hash(hash), openParen(openParen), parameters(parameters), closeParen(closeParen) {
        this->parameters.parent = this;
        for (auto child : this->parameters)
            child->parent = this;
    }

    explicit ParameterValueAssignmentSyntax(const ParameterValueAssignmentSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PatternSyntax : public SyntaxNode {

    PatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit PatternSyntax(const PatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT ParenthesizedPatternSyntax : public PatternSyntax {
    Token openParen;
    not_null<PatternSyntax*> pattern;
    Token closeParen;

    ParenthesizedPatternSyntax(Token openParen, PatternSyntax& pattern, Token closeParen) :
        PatternSyntax(SyntaxKind::ParenthesizedPattern), openParen(openParen), pattern(&pattern), closeParen(closeParen) {
        this->pattern->parent = this;
    }

    explicit ParenthesizedPatternSyntax(const ParenthesizedPatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT VariablePatternSyntax : public PatternSyntax {
    Token dot;
    Token variableName;

    VariablePatternSyntax(Token dot, Token variableName) :
        PatternSyntax(SyntaxKind::VariablePattern), dot(dot), variableName(variableName) {
    }

    explicit VariablePatternSyntax(const VariablePatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT WildcardPatternSyntax : public PatternSyntax {
    Token dot;
    Token star;

    WildcardPatternSyntax(Token dot, Token star) :
        PatternSyntax(SyntaxKind::WildcardPattern), dot(dot), star(star) {
    }

    explicit WildcardPatternSyntax(const WildcardPatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExpressionPatternSyntax : public PatternSyntax {
    not_null<ExpressionSyntax*> expr;

    ExpressionPatternSyntax(ExpressionSyntax& expr) :
        PatternSyntax(SyntaxKind::ExpressionPattern), expr(&expr) {
        this->expr->parent = this;
    }

    explicit ExpressionPatternSyntax(const ExpressionPatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TaggedPatternSyntax : public PatternSyntax {
    Token tagged;
    Token memberName;
    PatternSyntax* pattern;

    TaggedPatternSyntax(Token tagged, Token memberName, PatternSyntax* pattern) :
        PatternSyntax(SyntaxKind::TaggedPattern), tagged(tagged), memberName(memberName), pattern(pattern) {
        if (this->pattern) this->pattern->parent = this;
    }

    explicit TaggedPatternSyntax(const TaggedPatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StructurePatternMemberSyntax : public SyntaxNode {

    StructurePatternMemberSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit StructurePatternMemberSyntax(const StructurePatternMemberSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT OrderedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    not_null<PatternSyntax*> pattern;

    OrderedStructurePatternMemberSyntax(PatternSyntax& pattern) :
        StructurePatternMemberSyntax(SyntaxKind::OrderedStructurePatternMember), pattern(&pattern) {
        this->pattern->parent = this;
    }

    explicit OrderedStructurePatternMemberSyntax(const OrderedStructurePatternMemberSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NamedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    Token name;
    Token colon;
    not_null<PatternSyntax*> pattern;

    NamedStructurePatternMemberSyntax(Token name, Token colon, PatternSyntax& pattern) :
        StructurePatternMemberSyntax(SyntaxKind::NamedStructurePatternMember), name(name), colon(colon), pattern(&pattern) {
        this->pattern->parent = this;
    }

    explicit NamedStructurePatternMemberSyntax(const NamedStructurePatternMemberSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StructurePatternSyntax : public PatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<StructurePatternMemberSyntax> members;
    Token closeBrace;

    StructurePatternSyntax(Token openBrace, const SeparatedSyntaxList<StructurePatternMemberSyntax>& members, Token closeBrace) :
        PatternSyntax(SyntaxKind::StructurePattern), openBrace(openBrace), members(members), closeBrace(closeBrace) {
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
    }

    explicit StructurePatternSyntax(const StructurePatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT MatchesClauseSyntax : public SyntaxNode {
    Token matchesKeyword;
    not_null<PatternSyntax*> pattern;

    MatchesClauseSyntax(Token matchesKeyword, PatternSyntax& pattern) :
        SyntaxNode(SyntaxKind::MatchesClause), matchesKeyword(matchesKeyword), pattern(&pattern) {
        this->pattern->parent = this;
    }

    explicit MatchesClauseSyntax(const MatchesClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConditionalPatternSyntax : public SyntaxNode {
    not_null<ExpressionSyntax*> expr;
    MatchesClauseSyntax* matchesClause;

    ConditionalPatternSyntax(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause) :
        SyntaxNode(SyntaxKind::ConditionalPattern), expr(&expr), matchesClause(matchesClause) {
        this->expr->parent = this;
        if (this->matchesClause) this->matchesClause->parent = this;
    }

    explicit ConditionalPatternSyntax(const ConditionalPatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConditionalPredicateSyntax : public SyntaxNode {
    SeparatedSyntaxList<ConditionalPatternSyntax> conditions;

    ConditionalPredicateSyntax(const SeparatedSyntaxList<ConditionalPatternSyntax>& conditions) :
        SyntaxNode(SyntaxKind::ConditionalPredicate), conditions(conditions) {
        this->conditions.parent = this;
        for (auto child : this->conditions)
            child->parent = this;
    }

    explicit ConditionalPredicateSyntax(const ConditionalPredicateSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT AssignmentPatternSyntax : public SyntaxNode {

    AssignmentPatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit AssignmentPatternSyntax(const AssignmentPatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT SimpleAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token closeBrace;

    SimpleAssignmentPatternSyntax(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::SimpleAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit SimpleAssignmentPatternSyntax(const SimpleAssignmentPatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT AssignmentPatternItemSyntax : public SyntaxNode {
    not_null<ExpressionSyntax*> key;
    Token colon;
    not_null<ExpressionSyntax*> expr;

    AssignmentPatternItemSyntax(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::AssignmentPatternItem), key(&key), colon(colon), expr(&expr) {
        this->key->parent = this;
        this->expr->parent = this;
    }

    explicit AssignmentPatternItemSyntax(const AssignmentPatternItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StructuredAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<AssignmentPatternItemSyntax> items;
    Token closeBrace;

    StructuredAssignmentPatternSyntax(Token openBrace, const SeparatedSyntaxList<AssignmentPatternItemSyntax>& items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::StructuredAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit StructuredAssignmentPatternSyntax(const StructuredAssignmentPatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ReplicatedAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    not_null<ExpressionSyntax*> countExpr;
    Token innerOpenBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token innerCloseBrace;
    Token closeBrace;

    ReplicatedAssignmentPatternSyntax(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token innerCloseBrace, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::ReplicatedAssignmentPattern), openBrace(openBrace), countExpr(&countExpr), innerOpenBrace(innerOpenBrace), items(items), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace) {
        this->countExpr->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit ReplicatedAssignmentPatternSyntax(const ReplicatedAssignmentPatternSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BadExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> expr;

    BadExpressionSyntax(ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::BadExpression), expr(&expr) {
        this->expr->parent = this;
    }

    explicit BadExpressionSyntax(const BadExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PrimaryExpressionSyntax : public ExpressionSyntax {

    PrimaryExpressionSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind) {
    }

    explicit PrimaryExpressionSyntax(const PrimaryExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT PrefixUnaryExpressionSyntax : public ExpressionSyntax {
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    not_null<ExpressionSyntax*> operand;

    PrefixUnaryExpressionSyntax(SyntaxKind kind, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& operand) :
        ExpressionSyntax(kind), operatorToken(operatorToken), attributes(attributes), operand(&operand) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        this->operand->parent = this;
    }

    explicit PrefixUnaryExpressionSyntax(const PrefixUnaryExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PostfixUnaryExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> operand;
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token operatorToken;

    PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& operand, const SyntaxList<AttributeInstanceSyntax>& attributes, Token operatorToken) :
        ExpressionSyntax(kind), operand(&operand), attributes(attributes), operatorToken(operatorToken) {
        this->operand->parent = this;
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
    }

    explicit PostfixUnaryExpressionSyntax(const PostfixUnaryExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BinaryExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> left;
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    not_null<ExpressionSyntax*> right;

    BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& right) :
        ExpressionSyntax(kind), left(&left), operatorToken(operatorToken), attributes(attributes), right(&right) {
        this->left->parent = this;
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        this->right->parent = this;
    }

    explicit BinaryExpressionSyntax(const BinaryExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT MinTypMaxExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> min;
    Token colon1;
    not_null<ExpressionSyntax*> typ;
    Token colon2;
    not_null<ExpressionSyntax*> max;

    MinTypMaxExpressionSyntax(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max) :
        ExpressionSyntax(SyntaxKind::MinTypMaxExpression), min(&min), colon1(colon1), typ(&typ), colon2(colon2), max(&max) {
        this->min->parent = this;
        this->typ->parent = this;
        this->max->parent = this;
    }

    explicit MinTypMaxExpressionSyntax(const MinTypMaxExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TaggedUnionExpressionSyntax : public ExpressionSyntax {
    Token tagged;
    Token member;
    ExpressionSyntax* expr;

    TaggedUnionExpressionSyntax(Token tagged, Token member, ExpressionSyntax* expr) :
        ExpressionSyntax(SyntaxKind::TaggedUnionExpression), tagged(tagged), member(member), expr(expr) {
        if (this->expr) this->expr->parent = this;
    }

    explicit TaggedUnionExpressionSyntax(const TaggedUnionExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ValueRangeExpressionSyntax : public ExpressionSyntax {
    Token openBracket;
    not_null<ExpressionSyntax*> left;
    Token op;
    not_null<ExpressionSyntax*> right;
    Token closeBracket;

    ValueRangeExpressionSyntax(Token openBracket, ExpressionSyntax& left, Token op, ExpressionSyntax& right, Token closeBracket) :
        ExpressionSyntax(SyntaxKind::ValueRangeExpression), openBracket(openBracket), left(&left), op(op), right(&right), closeBracket(closeBracket) {
        this->left->parent = this;
        this->right->parent = this;
    }

    explicit ValueRangeExpressionSyntax(const ValueRangeExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RangeListSyntax : public SyntaxNode {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> valueRanges;
    Token closeBrace;

    RangeListSyntax(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& valueRanges, Token closeBrace) :
        SyntaxNode(SyntaxKind::RangeList), openBrace(openBrace), valueRanges(valueRanges), closeBrace(closeBrace) {
        this->valueRanges.parent = this;
        for (auto child : this->valueRanges)
            child->parent = this;
    }

    explicit RangeListSyntax(const RangeListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT InsideExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> expr;
    Token inside;
    not_null<RangeListSyntax*> ranges;

    InsideExpressionSyntax(ExpressionSyntax& expr, Token inside, RangeListSyntax& ranges) :
        ExpressionSyntax(SyntaxKind::InsideExpression), expr(&expr), inside(inside), ranges(&ranges) {
        this->expr->parent = this;
        this->ranges->parent = this;
    }

    explicit InsideExpressionSyntax(const InsideExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConditionalExpressionSyntax : public ExpressionSyntax {
    not_null<ConditionalPredicateSyntax*> predicate;
    Token question;
    SyntaxList<AttributeInstanceSyntax> attributes;
    not_null<ExpressionSyntax*> left;
    Token colon;
    not_null<ExpressionSyntax*> right;

    ConditionalExpressionSyntax(ConditionalPredicateSyntax& predicate, Token question, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::ConditionalExpression), predicate(&predicate), question(question), attributes(attributes), left(&left), colon(colon), right(&right) {
        this->predicate->parent = this;
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        this->left->parent = this;
        this->right->parent = this;
    }

    explicit ConditionalExpressionSyntax(const ConditionalExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT AssignmentPatternExpressionSyntax : public PrimaryExpressionSyntax {
    DataTypeSyntax* type;
    not_null<AssignmentPatternSyntax*> pattern;

    AssignmentPatternExpressionSyntax(DataTypeSyntax* type, AssignmentPatternSyntax& pattern) :
        PrimaryExpressionSyntax(SyntaxKind::AssignmentPatternExpression), type(type), pattern(&pattern) {
        if (this->type) this->type->parent = this;
        this->pattern->parent = this;
    }

    explicit AssignmentPatternExpressionSyntax(const AssignmentPatternExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SelectorSyntax : public SyntaxNode {

    SelectorSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit SelectorSyntax(const SelectorSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT BitSelectSyntax : public SelectorSyntax {
    not_null<ExpressionSyntax*> expr;

    BitSelectSyntax(ExpressionSyntax& expr) :
        SelectorSyntax(SyntaxKind::BitSelect), expr(&expr) {
        this->expr->parent = this;
    }

    explicit BitSelectSyntax(const BitSelectSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RangeSelectSyntax : public SelectorSyntax {
    not_null<ExpressionSyntax*> left;
    Token range;
    not_null<ExpressionSyntax*> right;

    RangeSelectSyntax(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right) :
        SelectorSyntax(kind), left(&left), range(range), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    explicit RangeSelectSyntax(const RangeSelectSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ElementSelectSyntax : public SyntaxNode {
    Token openBracket;
    SelectorSyntax* selector;
    Token closeBracket;

    ElementSelectSyntax(Token openBracket, SelectorSyntax* selector, Token closeBracket) :
        SyntaxNode(SyntaxKind::ElementSelect), openBracket(openBracket), selector(selector), closeBracket(closeBracket) {
        if (this->selector) this->selector->parent = this;
    }

    explicit ElementSelectSyntax(const ElementSelectSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NameSyntax : public ExpressionSyntax {

    NameSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind) {
    }

    explicit NameSyntax(const NameSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT IdentifierNameSyntax : public NameSyntax {
    Token identifier;

    IdentifierNameSyntax(Token identifier) :
        NameSyntax(SyntaxKind::IdentifierName), identifier(identifier) {
    }

    explicit IdentifierNameSyntax(const IdentifierNameSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SystemNameSyntax : public NameSyntax {
    Token systemIdentifier;

    SystemNameSyntax(Token systemIdentifier) :
        NameSyntax(SyntaxKind::SystemName), systemIdentifier(systemIdentifier) {
    }

    explicit SystemNameSyntax(const SystemNameSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT IdentifierSelectNameSyntax : public NameSyntax {
    Token identifier;
    SyntaxList<ElementSelectSyntax> selectors;

    IdentifierSelectNameSyntax(Token identifier, const SyntaxList<ElementSelectSyntax>& selectors) :
        NameSyntax(SyntaxKind::IdentifierSelectName), identifier(identifier), selectors(selectors) {
        this->selectors.parent = this;
        for (auto child : this->selectors)
            child->parent = this;
    }

    explicit IdentifierSelectNameSyntax(const IdentifierSelectNameSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EmptyIdentifierNameSyntax : public NameSyntax {
    Token placeholder;

    EmptyIdentifierNameSyntax(Token placeholder) :
        NameSyntax(SyntaxKind::EmptyIdentifierName), placeholder(placeholder) {
    }

    explicit EmptyIdentifierNameSyntax(const EmptyIdentifierNameSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT KeywordNameSyntax : public NameSyntax {
    Token keyword;

    KeywordNameSyntax(SyntaxKind kind, Token keyword) :
        NameSyntax(kind), keyword(keyword) {
    }

    explicit KeywordNameSyntax(const KeywordNameSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClassNameSyntax : public NameSyntax {
    Token identifier;
    not_null<ParameterValueAssignmentSyntax*> parameters;

    ClassNameSyntax(Token identifier, ParameterValueAssignmentSyntax& parameters) :
        NameSyntax(SyntaxKind::ClassName), identifier(identifier), parameters(&parameters) {
        this->parameters->parent = this;
    }

    explicit ClassNameSyntax(const ClassNameSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ScopedNameSyntax : public NameSyntax {
    not_null<NameSyntax*> left;
    Token separator;
    not_null<NameSyntax*> right;

    ScopedNameSyntax(NameSyntax& left, Token separator, NameSyntax& right) :
        NameSyntax(SyntaxKind::ScopedName), left(&left), separator(separator), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    explicit ScopedNameSyntax(const ScopedNameSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT LiteralExpressionSyntax : public PrimaryExpressionSyntax {
    Token literal;

    LiteralExpressionSyntax(SyntaxKind kind, Token literal) :
        PrimaryExpressionSyntax(kind), literal(literal) {
    }

    explicit LiteralExpressionSyntax(const LiteralExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT IntegerVectorExpressionSyntax : public PrimaryExpressionSyntax {
    Token size;
    Token base;
    Token value;

    IntegerVectorExpressionSyntax(Token size, Token base, Token value) :
        PrimaryExpressionSyntax(SyntaxKind::IntegerVectorExpression), size(size), base(base), value(value) {
    }

    explicit IntegerVectorExpressionSyntax(const IntegerVectorExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EmptyQueueExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token closeBrace;

    EmptyQueueExpressionSyntax(Token openBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::EmptyQueueExpression), openBrace(openBrace), closeBrace(closeBrace) {
    }

    explicit EmptyQueueExpressionSyntax(const EmptyQueueExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token closeBrace;

    ConcatenationExpressionSyntax(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::ConcatenationExpression), openBrace(openBrace), expressions(expressions), closeBrace(closeBrace) {
        this->expressions.parent = this;
        for (auto child : this->expressions)
            child->parent = this;
    }

    explicit ConcatenationExpressionSyntax(const ConcatenationExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT MultipleConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    not_null<ExpressionSyntax*> expression;
    not_null<ConcatenationExpressionSyntax*> concatenation;
    Token closeBrace;

    MultipleConcatenationExpressionSyntax(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::MultipleConcatenationExpression), openBrace(openBrace), expression(&expression), concatenation(&concatenation), closeBrace(closeBrace) {
        this->expression->parent = this;
        this->concatenation->parent = this;
    }

    explicit MultipleConcatenationExpressionSyntax(const MultipleConcatenationExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StreamExpressionWithRangeSyntax : public SyntaxNode {
    Token withKeyword;
    not_null<ElementSelectSyntax*> range;

    StreamExpressionWithRangeSyntax(Token withKeyword, ElementSelectSyntax& range) :
        SyntaxNode(SyntaxKind::StreamExpressionWithRange), withKeyword(withKeyword), range(&range) {
        this->range->parent = this;
    }

    explicit StreamExpressionWithRangeSyntax(const StreamExpressionWithRangeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StreamExpressionSyntax : public SyntaxNode {
    not_null<ExpressionSyntax*> expression;
    StreamExpressionWithRangeSyntax* withRange;

    StreamExpressionSyntax(ExpressionSyntax& expression, StreamExpressionWithRangeSyntax* withRange) :
        SyntaxNode(SyntaxKind::StreamExpression), expression(&expression), withRange(withRange) {
        this->expression->parent = this;
        if (this->withRange) this->withRange->parent = this;
    }

    explicit StreamExpressionSyntax(const StreamExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StreamingConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token operatorToken;
    ExpressionSyntax* sliceSize;
    Token innerOpenBrace;
    SeparatedSyntaxList<StreamExpressionSyntax> expressions;
    Token innerCloseBrace;
    Token closeBrace;

    StreamingConcatenationExpressionSyntax(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, const SeparatedSyntaxList<StreamExpressionSyntax>& expressions, Token innerCloseBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::StreamingConcatenationExpression), openBrace(openBrace), operatorToken(operatorToken), sliceSize(sliceSize), innerOpenBrace(innerOpenBrace), expressions(expressions), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace) {
        if (this->sliceSize) this->sliceSize->parent = this;
        this->expressions.parent = this;
        for (auto child : this->expressions)
            child->parent = this;
    }

    explicit StreamingConcatenationExpressionSyntax(const StreamingConcatenationExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParenthesizedExpressionSyntax : public PrimaryExpressionSyntax {
    Token openParen;
    not_null<ExpressionSyntax*> expression;
    Token closeParen;

    ParenthesizedExpressionSyntax(Token openParen, ExpressionSyntax& expression, Token closeParen) :
        PrimaryExpressionSyntax(SyntaxKind::ParenthesizedExpression), openParen(openParen), expression(&expression), closeParen(closeParen) {
        this->expression->parent = this;
    }

    explicit ParenthesizedExpressionSyntax(const ParenthesizedExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NewArrayExpressionSyntax : public ExpressionSyntax {
    not_null<NameSyntax*> newKeyword;
    Token openBracket;
    not_null<ExpressionSyntax*> sizeExpr;
    Token closeBracket;
    ParenthesizedExpressionSyntax* initializer;

    NewArrayExpressionSyntax(NameSyntax& newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer) :
        ExpressionSyntax(SyntaxKind::NewArrayExpression), newKeyword(&newKeyword), openBracket(openBracket), sizeExpr(&sizeExpr), closeBracket(closeBracket), initializer(initializer) {
        this->newKeyword->parent = this;
        this->sizeExpr->parent = this;
        if (this->initializer) this->initializer->parent = this;
    }

    explicit NewArrayExpressionSyntax(const NewArrayExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NewClassExpressionSyntax : public ExpressionSyntax {
    not_null<NameSyntax*> scopedNew;
    ArgumentListSyntax* argList;

    NewClassExpressionSyntax(NameSyntax& scopedNew, ArgumentListSyntax* argList) :
        ExpressionSyntax(SyntaxKind::NewClassExpression), scopedNew(&scopedNew), argList(argList) {
        this->scopedNew->parent = this;
        if (this->argList) this->argList->parent = this;
    }

    explicit NewClassExpressionSyntax(const NewClassExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CopyClassExpressionSyntax : public ExpressionSyntax {
    not_null<NameSyntax*> scopedNew;
    not_null<ExpressionSyntax*> expr;

    CopyClassExpressionSyntax(NameSyntax& scopedNew, ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::CopyClassExpression), scopedNew(&scopedNew), expr(&expr) {
        this->scopedNew->parent = this;
        this->expr->parent = this;
    }

    explicit CopyClassExpressionSyntax(const CopyClassExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SuperNewDefaultedArgsExpressionSyntax : public ExpressionSyntax {
    not_null<NameSyntax*> scopedNew;
    Token openParen;
    Token defaultKeyword;
    Token closeParen;

    SuperNewDefaultedArgsExpressionSyntax(NameSyntax& scopedNew, Token openParen, Token defaultKeyword, Token closeParen) :
        ExpressionSyntax(SyntaxKind::SuperNewDefaultedArgsExpression), scopedNew(&scopedNew), openParen(openParen), defaultKeyword(defaultKeyword), closeParen(closeParen) {
        this->scopedNew->parent = this;
    }

    explicit SuperNewDefaultedArgsExpressionSyntax(const SuperNewDefaultedArgsExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ElementSelectExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> left;
    not_null<ElementSelectSyntax*> select;

    ElementSelectExpressionSyntax(ExpressionSyntax& left, ElementSelectSyntax& select) :
        ExpressionSyntax(SyntaxKind::ElementSelectExpression), left(&left), select(&select) {
        this->left->parent = this;
        this->select->parent = this;
    }

    explicit ElementSelectExpressionSyntax(const ElementSelectExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT MemberAccessExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> left;
    Token dot;
    Token name;

    MemberAccessExpressionSyntax(ExpressionSyntax& left, Token dot, Token name) :
        ExpressionSyntax(SyntaxKind::MemberAccessExpression), left(&left), dot(dot), name(name) {
        this->left->parent = this;
    }

    explicit MemberAccessExpressionSyntax(const MemberAccessExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT InvocationExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> left;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ArgumentListSyntax* arguments;

    InvocationExpressionSyntax(ExpressionSyntax& left, const SyntaxList<AttributeInstanceSyntax>& attributes, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::InvocationExpression), left(&left), attributes(attributes), arguments(arguments) {
        this->left->parent = this;
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        if (this->arguments) this->arguments->parent = this;
    }

    explicit InvocationExpressionSyntax(const InvocationExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CastExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> left;
    Token apostrophe;
    not_null<ParenthesizedExpressionSyntax*> right;

    CastExpressionSyntax(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::CastExpression), left(&left), apostrophe(apostrophe), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    explicit CastExpressionSyntax(const CastExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SignedCastExpressionSyntax : public ExpressionSyntax {
    Token signing;
    Token apostrophe;
    not_null<ParenthesizedExpressionSyntax*> inner;

    SignedCastExpressionSyntax(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner) :
        ExpressionSyntax(SyntaxKind::SignedCastExpression), signing(signing), apostrophe(apostrophe), inner(&inner) {
        this->inner->parent = this;
    }

    explicit SignedCastExpressionSyntax(const SignedCastExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DelaySyntax : public TimingControlSyntax {
    Token hash;
    not_null<ExpressionSyntax*> delayValue;

    DelaySyntax(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue) :
        TimingControlSyntax(kind), hash(hash), delayValue(&delayValue) {
        this->delayValue->parent = this;
    }

    explicit DelaySyntax(const DelaySyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT Delay3Syntax : public TimingControlSyntax {
    Token hash;
    Token openParen;
    not_null<ExpressionSyntax*> delay1;
    Token comma1;
    ExpressionSyntax* delay2;
    Token comma2;
    ExpressionSyntax* delay3;
    Token closeParen;

    Delay3Syntax(Token hash, Token openParen, ExpressionSyntax& delay1, Token comma1, ExpressionSyntax* delay2, Token comma2, ExpressionSyntax* delay3, Token closeParen) :
        TimingControlSyntax(SyntaxKind::Delay3), hash(hash), openParen(openParen), delay1(&delay1), comma1(comma1), delay2(delay2), comma2(comma2), delay3(delay3), closeParen(closeParen) {
        this->delay1->parent = this;
        if (this->delay2) this->delay2->parent = this;
        if (this->delay3) this->delay3->parent = this;
    }

    explicit Delay3Syntax(const Delay3Syntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT OneStepDelaySyntax : public TimingControlSyntax {
    Token hash;
    Token oneStep;

    OneStepDelaySyntax(Token hash, Token oneStep) :
        TimingControlSyntax(SyntaxKind::OneStepDelay), hash(hash), oneStep(oneStep) {
    }

    explicit OneStepDelaySyntax(const OneStepDelaySyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EventControlSyntax : public TimingControlSyntax {
    Token at;
    not_null<ExpressionSyntax*> eventName;

    EventControlSyntax(Token at, ExpressionSyntax& eventName) :
        TimingControlSyntax(SyntaxKind::EventControl), at(at), eventName(&eventName) {
        this->eventName->parent = this;
    }

    explicit EventControlSyntax(const EventControlSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT IffEventClauseSyntax : public SyntaxNode {
    Token iff;
    not_null<ExpressionSyntax*> expr;

    IffEventClauseSyntax(Token iff, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::IffEventClause), iff(iff), expr(&expr) {
        this->expr->parent = this;
    }

    explicit IffEventClauseSyntax(const IffEventClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EventExpressionSyntax : public SequenceExprSyntax {

    EventExpressionSyntax(SyntaxKind kind) :
        SequenceExprSyntax(kind) {
    }

    explicit EventExpressionSyntax(const EventExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT SignalEventExpressionSyntax : public EventExpressionSyntax {
    Token edge;
    not_null<ExpressionSyntax*> expr;
    IffEventClauseSyntax* iffClause;

    SignalEventExpressionSyntax(Token edge, ExpressionSyntax& expr, IffEventClauseSyntax* iffClause) :
        EventExpressionSyntax(SyntaxKind::SignalEventExpression), edge(edge), expr(&expr), iffClause(iffClause) {
        this->expr->parent = this;
        if (this->iffClause) this->iffClause->parent = this;
    }

    explicit SignalEventExpressionSyntax(const SignalEventExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BinaryEventExpressionSyntax : public EventExpressionSyntax {
    not_null<EventExpressionSyntax*> left;
    Token operatorToken;
    not_null<EventExpressionSyntax*> right;

    BinaryEventExpressionSyntax(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right) :
        EventExpressionSyntax(SyntaxKind::BinaryEventExpression), left(&left), operatorToken(operatorToken), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    explicit BinaryEventExpressionSyntax(const BinaryEventExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParenthesizedEventExpressionSyntax : public EventExpressionSyntax {
    Token openParen;
    not_null<EventExpressionSyntax*> expr;
    Token closeParen;

    ParenthesizedEventExpressionSyntax(Token openParen, EventExpressionSyntax& expr, Token closeParen) :
        EventExpressionSyntax(SyntaxKind::ParenthesizedEventExpression), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    explicit ParenthesizedEventExpressionSyntax(const ParenthesizedEventExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ImplicitEventControlSyntax : public TimingControlSyntax {
    Token at;
    Token openParen;
    Token star;
    Token closeParen;

    ImplicitEventControlSyntax(Token at, Token openParen, Token star, Token closeParen) :
        TimingControlSyntax(SyntaxKind::ImplicitEventControl), at(at), openParen(openParen), star(star), closeParen(closeParen) {
    }

    explicit ImplicitEventControlSyntax(const ImplicitEventControlSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EventControlWithExpressionSyntax : public TimingControlSyntax {
    Token at;
    not_null<EventExpressionSyntax*> expr;

    EventControlWithExpressionSyntax(Token at, EventExpressionSyntax& expr) :
        TimingControlSyntax(SyntaxKind::EventControlWithExpression), at(at), expr(&expr) {
        this->expr->parent = this;
    }

    explicit EventControlWithExpressionSyntax(const EventControlWithExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RepeatedEventControlSyntax : public TimingControlSyntax {
    Token repeat;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    TimingControlSyntax* eventControl;

    RepeatedEventControlSyntax(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl) :
        TimingControlSyntax(SyntaxKind::RepeatedEventControl), repeat(repeat), openParen(openParen), expr(&expr), closeParen(closeParen), eventControl(eventControl) {
        this->expr->parent = this;
        if (this->eventControl) this->eventControl->parent = this;
    }

    explicit RepeatedEventControlSyntax(const RepeatedEventControlSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TimingControlExpressionSyntax : public ExpressionSyntax {
    not_null<TimingControlSyntax*> timing;
    not_null<ExpressionSyntax*> expr;

    TimingControlExpressionSyntax(TimingControlSyntax& timing, ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::TimingControlExpression), timing(&timing), expr(&expr) {
        this->timing->parent = this;
        this->expr->parent = this;
    }

    explicit TimingControlExpressionSyntax(const TimingControlExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DimensionSpecifierSyntax : public SyntaxNode {

    DimensionSpecifierSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit DimensionSpecifierSyntax(const DimensionSpecifierSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT RangeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    not_null<SelectorSyntax*> selector;

    RangeDimensionSpecifierSyntax(SelectorSyntax& selector) :
        DimensionSpecifierSyntax(SyntaxKind::RangeDimensionSpecifier), selector(&selector) {
        this->selector->parent = this;
    }

    explicit RangeDimensionSpecifierSyntax(const RangeDimensionSpecifierSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT WildcardDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token star;

    WildcardDimensionSpecifierSyntax(Token star) :
        DimensionSpecifierSyntax(SyntaxKind::WildcardDimensionSpecifier), star(star) {
    }

    explicit WildcardDimensionSpecifierSyntax(const WildcardDimensionSpecifierSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ColonExpressionClauseSyntax : public SyntaxNode {
    Token colon;
    not_null<ExpressionSyntax*> expr;

    ColonExpressionClauseSyntax(Token colon, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::ColonExpressionClause), colon(colon), expr(&expr) {
        this->expr->parent = this;
    }

    explicit ColonExpressionClauseSyntax(const ColonExpressionClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT QueueDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token dollar;
    ColonExpressionClauseSyntax* maxSizeClause;

    QueueDimensionSpecifierSyntax(Token dollar, ColonExpressionClauseSyntax* maxSizeClause) :
        DimensionSpecifierSyntax(SyntaxKind::QueueDimensionSpecifier), dollar(dollar), maxSizeClause(maxSizeClause) {
        if (this->maxSizeClause) this->maxSizeClause->parent = this;
    }

    explicit QueueDimensionSpecifierSyntax(const QueueDimensionSpecifierSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT VariableDimensionSyntax : public SyntaxNode {
    Token openBracket;
    DimensionSpecifierSyntax* specifier;
    Token closeBracket;

    VariableDimensionSyntax(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket) :
        SyntaxNode(SyntaxKind::VariableDimension), openBracket(openBracket), specifier(specifier), closeBracket(closeBracket) {
        if (this->specifier) this->specifier->parent = this;
    }

    explicit VariableDimensionSyntax(const VariableDimensionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DeclaratorSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    EqualsValueClauseSyntax* initializer;

    DeclaratorSyntax(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, EqualsValueClauseSyntax* initializer) :
        SyntaxNode(SyntaxKind::Declarator), name(name), dimensions(dimensions), initializer(initializer) {
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
        if (this->initializer) this->initializer->parent = this;
    }

    explicit DeclaratorSyntax(const DeclaratorSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DataDeclarationSyntax : public MemberSyntax {
    TokenList modifiers;
    not_null<DataTypeSyntax*> type;
    SeparatedSyntaxList<DeclaratorSyntax> declarators;
    Token semi;

    DataDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& modifiers, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
        MemberSyntax(SyntaxKind::DataDeclaration, attributes), modifiers(modifiers), type(&type), declarators(declarators), semi(semi) {
        this->modifiers.parent = this;
        this->type->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    explicit DataDeclarationSyntax(const DataDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ForwardTypeRestrictionSyntax : public SyntaxNode {
    Token keyword1;
    Token keyword2;

    ForwardTypeRestrictionSyntax(Token keyword1, Token keyword2) :
        SyntaxNode(SyntaxKind::ForwardTypeRestriction), keyword1(keyword1), keyword2(keyword2) {
    }

    explicit ForwardTypeRestrictionSyntax(const ForwardTypeRestrictionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TypedefDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    not_null<DataTypeSyntax*> type;
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token semi;

    TypedefDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token semi) :
        MemberSyntax(SyntaxKind::TypedefDeclaration, attributes), typedefKeyword(typedefKeyword), type(&type), name(name), dimensions(dimensions), semi(semi) {
        this->type->parent = this;
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
    }

    explicit TypedefDeclarationSyntax(const TypedefDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ForwardTypedefDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    ForwardTypeRestrictionSyntax* typeRestriction;
    Token name;
    Token semi;

    ForwardTypedefDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, ForwardTypeRestrictionSyntax* typeRestriction, Token name, Token semi) :
        MemberSyntax(SyntaxKind::ForwardTypedefDeclaration, attributes), typedefKeyword(typedefKeyword), typeRestriction(typeRestriction), name(name), semi(semi) {
        if (this->typeRestriction) this->typeRestriction->parent = this;
    }

    explicit ForwardTypedefDeclarationSyntax(const ForwardTypedefDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NetStrengthSyntax : public SyntaxNode {

    NetStrengthSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit NetStrengthSyntax(const NetStrengthSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT ChargeStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength;
    Token closeParen;

    ChargeStrengthSyntax(Token openParen, Token strength, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::ChargeStrength), openParen(openParen), strength(strength), closeParen(closeParen) {
    }

    explicit ChargeStrengthSyntax(const ChargeStrengthSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DriveStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength0;
    Token comma;
    Token strength1;
    Token closeParen;

    DriveStrengthSyntax(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::DriveStrength), openParen(openParen), strength0(strength0), comma(comma), strength1(strength1), closeParen(closeParen) {
    }

    explicit DriveStrengthSyntax(const DriveStrengthSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PullStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength;
    Token closeParen;

    PullStrengthSyntax(Token openParen, Token strength, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::PullStrength), openParen(openParen), strength(strength), closeParen(closeParen) {
    }

    explicit PullStrengthSyntax(const PullStrengthSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NetDeclarationSyntax : public MemberSyntax {
    Token netType;
    NetStrengthSyntax* strength;
    Token expansionHint;
    not_null<DataTypeSyntax*> type;
    TimingControlSyntax* delay;
    SeparatedSyntaxList<DeclaratorSyntax> declarators;
    Token semi;

    NetDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, TimingControlSyntax* delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
        MemberSyntax(SyntaxKind::NetDeclaration, attributes), netType(netType), strength(strength), expansionHint(expansionHint), type(&type), delay(delay), declarators(declarators), semi(semi) {
        if (this->strength) this->strength->parent = this;
        this->type->parent = this;
        if (this->delay) this->delay->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    explicit NetDeclarationSyntax(const NetDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UserDefinedNetDeclarationSyntax : public MemberSyntax {
    Token netType;
    not_null<TimingControlSyntax*> delay;
    SeparatedSyntaxList<DeclaratorSyntax> declarators;
    Token semi;

    UserDefinedNetDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, TimingControlSyntax& delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
        MemberSyntax(SyntaxKind::UserDefinedNetDeclaration, attributes), netType(netType), delay(&delay), declarators(declarators), semi(semi) {
        this->delay->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    explicit UserDefinedNetDeclarationSyntax(const UserDefinedNetDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT WithFunctionClauseSyntax : public SyntaxNode {
    Token with;
    not_null<NameSyntax*> name;

    WithFunctionClauseSyntax(Token with, NameSyntax& name) :
        SyntaxNode(SyntaxKind::WithFunctionClause), with(with), name(&name) {
        this->name->parent = this;
    }

    explicit WithFunctionClauseSyntax(const WithFunctionClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NetTypeDeclarationSyntax : public MemberSyntax {
    Token keyword;
    not_null<DataTypeSyntax*> type;
    Token name;
    WithFunctionClauseSyntax* withFunction;
    Token semi;

    NetTypeDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DataTypeSyntax& type, Token name, WithFunctionClauseSyntax* withFunction, Token semi) :
        MemberSyntax(SyntaxKind::NetTypeDeclaration, attributes), keyword(keyword), type(&type), name(name), withFunction(withFunction), semi(semi) {
        this->type->parent = this;
        if (this->withFunction) this->withFunction->parent = this;
    }

    explicit NetTypeDeclarationSyntax(const NetTypeDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PackageImportItemSyntax : public SyntaxNode {
    Token package;
    Token doubleColon;
    Token item;

    PackageImportItemSyntax(Token package, Token doubleColon, Token item) :
        SyntaxNode(SyntaxKind::PackageImportItem), package(package), doubleColon(doubleColon), item(item) {
    }

    explicit PackageImportItemSyntax(const PackageImportItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PackageImportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<PackageImportItemSyntax> items;
    Token semi;

    PackageImportDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<PackageImportItemSyntax>& items, Token semi) :
        MemberSyntax(SyntaxKind::PackageImportDeclaration, attributes), keyword(keyword), items(items), semi(semi) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit PackageImportDeclarationSyntax(const PackageImportDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PackageExportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<PackageImportItemSyntax> items;
    Token semi;

    PackageExportDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<PackageImportItemSyntax>& items, Token semi) :
        MemberSyntax(SyntaxKind::PackageExportDeclaration, attributes), keyword(keyword), items(items), semi(semi) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit PackageExportDeclarationSyntax(const PackageExportDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PackageExportAllDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token star1;
    Token doubleColon;
    Token star2;
    Token semi;

    PackageExportAllDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token star1, Token doubleColon, Token star2, Token semi) :
        MemberSyntax(SyntaxKind::PackageExportAllDeclaration, attributes), keyword(keyword), star1(star1), doubleColon(doubleColon), star2(star2), semi(semi) {
    }

    explicit PackageExportAllDeclarationSyntax(const PackageExportAllDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParameterDeclarationBaseSyntax : public SyntaxNode {
    Token keyword;

    ParameterDeclarationBaseSyntax(SyntaxKind kind, Token keyword) :
        SyntaxNode(kind), keyword(keyword) {
    }

    explicit ParameterDeclarationBaseSyntax(const ParameterDeclarationBaseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParameterDeclarationSyntax : public ParameterDeclarationBaseSyntax {
    not_null<DataTypeSyntax*> type;
    SeparatedSyntaxList<DeclaratorSyntax> declarators;

    ParameterDeclarationSyntax(Token keyword, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators) :
        ParameterDeclarationBaseSyntax(SyntaxKind::ParameterDeclaration, keyword), type(&type), declarators(declarators) {
        this->type->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    explicit ParameterDeclarationSyntax(const ParameterDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EqualsTypeClauseSyntax : public SyntaxNode {
    Token equals;
    not_null<DataTypeSyntax*> type;

    EqualsTypeClauseSyntax(Token equals, DataTypeSyntax& type) :
        SyntaxNode(SyntaxKind::EqualsTypeClause), equals(equals), type(&type) {
        this->type->parent = this;
    }

    explicit EqualsTypeClauseSyntax(const EqualsTypeClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TypeAssignmentSyntax : public SyntaxNode {
    Token name;
    EqualsTypeClauseSyntax* assignment;

    TypeAssignmentSyntax(Token name, EqualsTypeClauseSyntax* assignment) :
        SyntaxNode(SyntaxKind::TypeAssignment), name(name), assignment(assignment) {
        if (this->assignment) this->assignment->parent = this;
    }

    explicit TypeAssignmentSyntax(const TypeAssignmentSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TypeParameterDeclarationSyntax : public ParameterDeclarationBaseSyntax {
    Token typeKeyword;
    ForwardTypeRestrictionSyntax* typeRestriction;
    SeparatedSyntaxList<TypeAssignmentSyntax> declarators;

    TypeParameterDeclarationSyntax(Token keyword, Token typeKeyword, ForwardTypeRestrictionSyntax* typeRestriction, const SeparatedSyntaxList<TypeAssignmentSyntax>& declarators) :
        ParameterDeclarationBaseSyntax(SyntaxKind::TypeParameterDeclaration, keyword), typeKeyword(typeKeyword), typeRestriction(typeRestriction), declarators(declarators) {
        if (this->typeRestriction) this->typeRestriction->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    explicit TypeParameterDeclarationSyntax(const TypeParameterDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParameterDeclarationStatementSyntax : public MemberSyntax {
    not_null<ParameterDeclarationBaseSyntax*> parameter;
    Token semi;

    ParameterDeclarationStatementSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ParameterDeclarationBaseSyntax& parameter, Token semi) :
        MemberSyntax(SyntaxKind::ParameterDeclarationStatement, attributes), parameter(&parameter), semi(semi) {
        this->parameter->parent = this;
    }

    explicit ParameterDeclarationStatementSyntax(const ParameterDeclarationStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PortHeaderSyntax : public SyntaxNode {

    PortHeaderSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit PortHeaderSyntax(const PortHeaderSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT PortDeclarationSyntax : public MemberSyntax {
    not_null<PortHeaderSyntax*> header;
    SeparatedSyntaxList<DeclaratorSyntax> declarators;
    Token semi;

    PortDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
        MemberSyntax(SyntaxKind::PortDeclaration, attributes), header(&header), declarators(declarators), semi(semi) {
        this->header->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    explicit PortDeclarationSyntax(const PortDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT GenvarDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
    Token semi;

    GenvarDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& identifiers, Token semi) :
        MemberSyntax(SyntaxKind::GenvarDeclaration, attributes), keyword(keyword), identifiers(identifiers), semi(semi) {
        this->identifiers.parent = this;
        for (auto child : this->identifiers)
            child->parent = this;
    }

    explicit GenvarDeclarationSyntax(const GenvarDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT FunctionPortBaseSyntax : public SyntaxNode {

    FunctionPortBaseSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit FunctionPortBaseSyntax(const FunctionPortBaseSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT DefaultFunctionPortSyntax : public FunctionPortBaseSyntax {
    Token keyword;

    DefaultFunctionPortSyntax(Token keyword) :
        FunctionPortBaseSyntax(SyntaxKind::DefaultFunctionPort), keyword(keyword) {
    }

    explicit DefaultFunctionPortSyntax(const DefaultFunctionPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT FunctionPortSyntax : public FunctionPortBaseSyntax {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token constKeyword;
    Token direction;
    Token staticKeyword;
    Token varKeyword;
    DataTypeSyntax* dataType;
    not_null<DeclaratorSyntax*> declarator;

    FunctionPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token constKeyword, Token direction, Token staticKeyword, Token varKeyword, DataTypeSyntax* dataType, DeclaratorSyntax& declarator) :
        FunctionPortBaseSyntax(SyntaxKind::FunctionPort), attributes(attributes), constKeyword(constKeyword), direction(direction), staticKeyword(staticKeyword), varKeyword(varKeyword), dataType(dataType), declarator(&declarator) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        if (this->dataType) this->dataType->parent = this;
        this->declarator->parent = this;
    }

    explicit FunctionPortSyntax(const FunctionPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT FunctionPortListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<FunctionPortBaseSyntax> ports;
    Token closeParen;

    FunctionPortListSyntax(Token openParen, const SeparatedSyntaxList<FunctionPortBaseSyntax>& ports, Token closeParen) :
        SyntaxNode(SyntaxKind::FunctionPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    explicit FunctionPortListSyntax(const FunctionPortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT IntegerTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    IntegerTypeSyntax(SyntaxKind kind, Token keyword, Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions) :
        DataTypeSyntax(kind), keyword(keyword), signing(signing), dimensions(dimensions) {
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
    }

    explicit IntegerTypeSyntax(const IntegerTypeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT KeywordTypeSyntax : public DataTypeSyntax {
    Token keyword;

    KeywordTypeSyntax(SyntaxKind kind, Token keyword) :
        DataTypeSyntax(kind), keyword(keyword) {
    }

    explicit KeywordTypeSyntax(const KeywordTypeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NamedTypeSyntax : public DataTypeSyntax {
    not_null<NameSyntax*> name;

    NamedTypeSyntax(NameSyntax& name) :
        DataTypeSyntax(SyntaxKind::NamedType), name(&name) {
        this->name->parent = this;
    }

    explicit NamedTypeSyntax(const NamedTypeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StructUnionMemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token randomQualifier;
    not_null<DataTypeSyntax*> type;
    SeparatedSyntaxList<DeclaratorSyntax> declarators;
    Token semi;

    StructUnionMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token randomQualifier, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
        SyntaxNode(SyntaxKind::StructUnionMember), attributes(attributes), randomQualifier(randomQualifier), type(&type), declarators(declarators), semi(semi) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        this->type->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    explicit StructUnionMemberSyntax(const StructUnionMemberSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StructUnionTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token taggedOrSoft;
    Token packed;
    Token signing;
    Token openBrace;
    SyntaxList<StructUnionMemberSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    StructUnionTypeSyntax(SyntaxKind kind, Token keyword, Token taggedOrSoft, Token packed, Token signing, Token openBrace, const SyntaxList<StructUnionMemberSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions) :
        DataTypeSyntax(kind), keyword(keyword), taggedOrSoft(taggedOrSoft), packed(packed), signing(signing), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions) {
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
    }

    explicit StructUnionTypeSyntax(const StructUnionTypeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EnumTypeSyntax : public DataTypeSyntax {
    Token keyword;
    DataTypeSyntax* baseType;
    Token openBrace;
    SeparatedSyntaxList<DeclaratorSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    EnumTypeSyntax(Token keyword, DataTypeSyntax* baseType, Token openBrace, const SeparatedSyntaxList<DeclaratorSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions) :
        DataTypeSyntax(SyntaxKind::EnumType), keyword(keyword), baseType(baseType), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions) {
        if (this->baseType) this->baseType->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
    }

    explicit EnumTypeSyntax(const EnumTypeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TypeReferenceSyntax : public DataTypeSyntax {
    Token typeKeyword;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;

    TypeReferenceSyntax(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        DataTypeSyntax(SyntaxKind::TypeReference), typeKeyword(typeKeyword), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    explicit TypeReferenceSyntax(const TypeReferenceSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DotMemberClauseSyntax : public SyntaxNode {
    Token dot;
    Token member;

    DotMemberClauseSyntax(Token dot, Token member) :
        SyntaxNode(SyntaxKind::DotMemberClause), dot(dot), member(member) {
    }

    explicit DotMemberClauseSyntax(const DotMemberClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT VirtualInterfaceTypeSyntax : public DataTypeSyntax {
    Token virtualKeyword;
    Token interfaceKeyword;
    Token name;
    ParameterValueAssignmentSyntax* parameters;
    DotMemberClauseSyntax* modport;

    VirtualInterfaceTypeSyntax(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) :
        DataTypeSyntax(SyntaxKind::VirtualInterfaceType), virtualKeyword(virtualKeyword), interfaceKeyword(interfaceKeyword), name(name), parameters(parameters), modport(modport) {
        if (this->parameters) this->parameters->parent = this;
        if (this->modport) this->modport->parent = this;
    }

    explicit VirtualInterfaceTypeSyntax(const VirtualInterfaceTypeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ImplicitTypeSyntax : public DataTypeSyntax {
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token placeholder;

    ImplicitTypeSyntax(Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions, Token placeholder) :
        DataTypeSyntax(SyntaxKind::ImplicitType), signing(signing), dimensions(dimensions), placeholder(placeholder) {
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
    }

    explicit ImplicitTypeSyntax(const ImplicitTypeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DeferredAssertionSyntax : public SyntaxNode {
    Token hash;
    Token zero;
    Token finalKeyword;

    DeferredAssertionSyntax(Token hash, Token zero, Token finalKeyword) :
        SyntaxNode(SyntaxKind::DeferredAssertion), hash(hash), zero(zero), finalKeyword(finalKeyword) {
    }

    explicit DeferredAssertionSyntax(const DeferredAssertionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ElseClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    not_null<SyntaxNode*> clause;

    ElseClauseSyntax(Token elseKeyword, SyntaxNode& clause) :
        SyntaxNode(SyntaxKind::ElseClause), elseKeyword(elseKeyword), clause(&clause) {
        this->clause->parent = this;
    }

    explicit ElseClauseSyntax(const ElseClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ActionBlockSyntax : public SyntaxNode {
    StatementSyntax* statement;
    ElseClauseSyntax* elseClause;

    ActionBlockSyntax(StatementSyntax* statement, ElseClauseSyntax* elseClause) :
        SyntaxNode(SyntaxKind::ActionBlock), statement(statement), elseClause(elseClause) {
        if (this->statement) this->statement->parent = this;
        if (this->elseClause) this->elseClause->parent = this;
    }

    explicit ActionBlockSyntax(const ActionBlockSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ImmediateAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    DeferredAssertionSyntax* delay;
    not_null<ParenthesizedExpressionSyntax*> expr;
    not_null<ActionBlockSyntax*> action;

    ImmediateAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), delay(delay), expr(&expr), action(&action) {
        if (this->delay) this->delay->parent = this;
        this->expr->parent = this;
        this->action->parent = this;
    }

    explicit ImmediateAssertionStatementSyntax(const ImmediateAssertionStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DisableIffSyntax : public SyntaxNode {
    Token disable;
    Token iff;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;

    DisableIffSyntax(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::DisableIff), disable(disable), iff(iff), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    explicit DisableIffSyntax(const DisableIffSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PropertySpecSyntax : public SyntaxNode {
    TimingControlSyntax* clocking;
    DisableIffSyntax* disable;
    not_null<PropertyExprSyntax*> expr;

    PropertySpecSyntax(TimingControlSyntax* clocking, DisableIffSyntax* disable, PropertyExprSyntax& expr) :
        SyntaxNode(SyntaxKind::PropertySpec), clocking(clocking), disable(disable), expr(&expr) {
        if (this->clocking) this->clocking->parent = this;
        if (this->disable) this->disable->parent = this;
        this->expr->parent = this;
    }

    explicit PropertySpecSyntax(const PropertySpecSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConcurrentAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    Token propertyOrSequence;
    Token openParen;
    not_null<PropertySpecSyntax*> propertySpec;
    Token closeParen;
    not_null<ActionBlockSyntax*> action;

    ConcurrentAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), propertyOrSequence(propertyOrSequence), openParen(openParen), propertySpec(&propertySpec), closeParen(closeParen), action(&action) {
        this->propertySpec->parent = this;
        this->action->parent = this;
    }

    explicit ConcurrentAssertionStatementSyntax(const ConcurrentAssertionStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConcurrentAssertionMemberSyntax : public MemberSyntax {
    not_null<ConcurrentAssertionStatementSyntax*> statement;

    ConcurrentAssertionMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ConcurrentAssertionStatementSyntax& statement) :
        MemberSyntax(SyntaxKind::ConcurrentAssertionMember, attributes), statement(&statement) {
        this->statement->parent = this;
    }

    explicit ConcurrentAssertionMemberSyntax(const ConcurrentAssertionMemberSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ImmediateAssertionMemberSyntax : public MemberSyntax {
    not_null<ImmediateAssertionStatementSyntax*> statement;

    ImmediateAssertionMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ImmediateAssertionStatementSyntax& statement) :
        MemberSyntax(SyntaxKind::ImmediateAssertionMember, attributes), statement(&statement) {
        this->statement->parent = this;
    }

    explicit ImmediateAssertionMemberSyntax(const ImmediateAssertionMemberSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EmptyStatementSyntax : public StatementSyntax {
    Token semicolon;

    EmptyStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token semicolon) :
        StatementSyntax(SyntaxKind::EmptyStatement, label, attributes), semicolon(semicolon) {
    }

    explicit EmptyStatementSyntax(const EmptyStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConditionalStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token ifKeyword;
    Token openParen;
    not_null<ConditionalPredicateSyntax*> predicate;
    Token closeParen;
    not_null<StatementSyntax*> statement;
    ElseClauseSyntax* elseClause;

    ConditionalStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause) :
        StatementSyntax(SyntaxKind::ConditionalStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), ifKeyword(ifKeyword), openParen(openParen), predicate(&predicate), closeParen(closeParen), statement(&statement), elseClause(elseClause) {
        this->predicate->parent = this;
        this->statement->parent = this;
        if (this->elseClause) this->elseClause->parent = this;
    }

    explicit ConditionalStatementSyntax(const ConditionalStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CaseItemSyntax : public SyntaxNode {

    CaseItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit CaseItemSyntax(const CaseItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT DefaultCaseItemSyntax : public CaseItemSyntax {
    Token defaultKeyword;
    Token colon;
    not_null<SyntaxNode*> clause;

    DefaultCaseItemSyntax(Token defaultKeyword, Token colon, SyntaxNode& clause) :
        CaseItemSyntax(SyntaxKind::DefaultCaseItem), defaultKeyword(defaultKeyword), colon(colon), clause(&clause) {
        this->clause->parent = this;
    }

    explicit DefaultCaseItemSyntax(const DefaultCaseItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PatternCaseItemSyntax : public CaseItemSyntax {
    not_null<PatternSyntax*> pattern;
    Token tripleAnd;
    ExpressionSyntax* expr;
    Token colon;
    not_null<StatementSyntax*> statement;

    PatternCaseItemSyntax(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement) :
        CaseItemSyntax(SyntaxKind::PatternCaseItem), pattern(&pattern), tripleAnd(tripleAnd), expr(expr), colon(colon), statement(&statement) {
        this->pattern->parent = this;
        if (this->expr) this->expr->parent = this;
        this->statement->parent = this;
    }

    explicit PatternCaseItemSyntax(const PatternCaseItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StandardCaseItemSyntax : public CaseItemSyntax {
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token colon;
    not_null<SyntaxNode*> clause;

    StandardCaseItemSyntax(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, SyntaxNode& clause) :
        CaseItemSyntax(SyntaxKind::StandardCaseItem), expressions(expressions), colon(colon), clause(&clause) {
        this->expressions.parent = this;
        for (auto child : this->expressions)
            child->parent = this;
        this->clause->parent = this;
    }

    explicit StandardCaseItemSyntax(const StandardCaseItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CaseStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token caseKeyword;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    Token matchesOrInside;
    SyntaxList<CaseItemSyntax> items;
    Token endcase;

    CaseStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, const SyntaxList<CaseItemSyntax>& items, Token endcase) :
        StatementSyntax(SyntaxKind::CaseStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), caseKeyword(caseKeyword), openParen(openParen), expr(&expr), closeParen(closeParen), matchesOrInside(matchesOrInside), items(items), endcase(endcase) {
        this->expr->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit CaseStatementSyntax(const CaseStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ForeverStatementSyntax : public StatementSyntax {
    Token foreverKeyword;
    not_null<StatementSyntax*> statement;

    ForeverStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token foreverKeyword, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForeverStatement, label, attributes), foreverKeyword(foreverKeyword), statement(&statement) {
        this->statement->parent = this;
    }

    explicit ForeverStatementSyntax(const ForeverStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT LoopStatementSyntax : public StatementSyntax {
    Token repeatOrWhile;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    not_null<StatementSyntax*> statement;

    LoopStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::LoopStatement, label, attributes), repeatOrWhile(repeatOrWhile), openParen(openParen), expr(&expr), closeParen(closeParen), statement(&statement) {
        this->expr->parent = this;
        this->statement->parent = this;
    }

    explicit LoopStatementSyntax(const LoopStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DoWhileStatementSyntax : public StatementSyntax {
    Token doKeyword;
    not_null<StatementSyntax*> statement;
    Token whileKeyword;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    Token semi;

    DoWhileStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) :
        StatementSyntax(SyntaxKind::DoWhileStatement, label, attributes), doKeyword(doKeyword), statement(&statement), whileKeyword(whileKeyword), openParen(openParen), expr(&expr), closeParen(closeParen), semi(semi) {
        this->statement->parent = this;
        this->expr->parent = this;
    }

    explicit DoWhileStatementSyntax(const DoWhileStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ForVariableDeclarationSyntax : public SyntaxNode {
    Token varKeyword;
    DataTypeSyntax* type;
    not_null<DeclaratorSyntax*> declarator;

    ForVariableDeclarationSyntax(Token varKeyword, DataTypeSyntax* type, DeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::ForVariableDeclaration), varKeyword(varKeyword), type(type), declarator(&declarator) {
        if (this->type) this->type->parent = this;
        this->declarator->parent = this;
    }

    explicit ForVariableDeclarationSyntax(const ForVariableDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ForLoopStatementSyntax : public StatementSyntax {
    Token forKeyword;
    Token openParen;
    SeparatedSyntaxList<SyntaxNode> initializers;
    Token semi1;
    ExpressionSyntax* stopExpr;
    Token semi2;
    SeparatedSyntaxList<ExpressionSyntax> steps;
    Token closeParen;
    not_null<StatementSyntax*> statement;

    ForLoopStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token forKeyword, Token openParen, const SeparatedSyntaxList<SyntaxNode>& initializers, Token semi1, ExpressionSyntax* stopExpr, Token semi2, const SeparatedSyntaxList<ExpressionSyntax>& steps, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForLoopStatement, label, attributes), forKeyword(forKeyword), openParen(openParen), initializers(initializers), semi1(semi1), stopExpr(stopExpr), semi2(semi2), steps(steps), closeParen(closeParen), statement(&statement) {
        this->initializers.parent = this;
        for (auto child : this->initializers)
            child->parent = this;
        if (this->stopExpr) this->stopExpr->parent = this;
        this->steps.parent = this;
        for (auto child : this->steps)
            child->parent = this;
        this->statement->parent = this;
    }

    explicit ForLoopStatementSyntax(const ForLoopStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ForeachLoopListSyntax : public SyntaxNode {
    Token openParen;
    not_null<NameSyntax*> arrayName;
    Token openBracket;
    SeparatedSyntaxList<NameSyntax> loopVariables;
    Token closeBracket;
    Token closeParen;

    ForeachLoopListSyntax(Token openParen, NameSyntax& arrayName, Token openBracket, const SeparatedSyntaxList<NameSyntax>& loopVariables, Token closeBracket, Token closeParen) :
        SyntaxNode(SyntaxKind::ForeachLoopList), openParen(openParen), arrayName(&arrayName), openBracket(openBracket), loopVariables(loopVariables), closeBracket(closeBracket), closeParen(closeParen) {
        this->arrayName->parent = this;
        this->loopVariables.parent = this;
        for (auto child : this->loopVariables)
            child->parent = this;
    }

    explicit ForeachLoopListSyntax(const ForeachLoopListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ForeachLoopStatementSyntax : public StatementSyntax {
    Token keyword;
    not_null<ForeachLoopListSyntax*> loopList;
    not_null<StatementSyntax*> statement;

    ForeachLoopStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForeachLoopStatement, label, attributes), keyword(keyword), loopList(&loopList), statement(&statement) {
        this->loopList->parent = this;
        this->statement->parent = this;
    }

    explicit ForeachLoopStatementSyntax(const ForeachLoopStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ReturnStatementSyntax : public StatementSyntax {
    Token returnKeyword;
    ExpressionSyntax* returnValue;
    Token semi;

    ReturnStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi) :
        StatementSyntax(SyntaxKind::ReturnStatement, label, attributes), returnKeyword(returnKeyword), returnValue(returnValue), semi(semi) {
        if (this->returnValue) this->returnValue->parent = this;
    }

    explicit ReturnStatementSyntax(const ReturnStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT JumpStatementSyntax : public StatementSyntax {
    Token breakOrContinue;
    Token semi;

    JumpStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token breakOrContinue, Token semi) :
        StatementSyntax(SyntaxKind::JumpStatement, label, attributes), breakOrContinue(breakOrContinue), semi(semi) {
    }

    explicit JumpStatementSyntax(const JumpStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TimingControlStatementSyntax : public StatementSyntax {
    not_null<TimingControlSyntax*> timingControl;
    not_null<StatementSyntax*> statement;

    TimingControlStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, TimingControlSyntax& timingControl, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::TimingControlStatement, label, attributes), timingControl(&timingControl), statement(&statement) {
        this->timingControl->parent = this;
        this->statement->parent = this;
    }

    explicit TimingControlStatementSyntax(const TimingControlStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExpressionStatementSyntax : public StatementSyntax {
    not_null<ExpressionSyntax*> expr;
    Token semi;

    ExpressionStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr, Token semi) :
        StatementSyntax(SyntaxKind::ExpressionStatement, label, attributes), expr(&expr), semi(semi) {
        this->expr->parent = this;
    }

    explicit ExpressionStatementSyntax(const ExpressionStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT VoidCastedCallStatementSyntax : public StatementSyntax {
    Token voidKeyword;
    Token apostrophe;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    Token semi;

    VoidCastedCallStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token voidKeyword, Token apostrophe, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) :
        StatementSyntax(SyntaxKind::VoidCastedCallStatement, label, attributes), voidKeyword(voidKeyword), apostrophe(apostrophe), openParen(openParen), expr(&expr), closeParen(closeParen), semi(semi) {
        this->expr->parent = this;
    }

    explicit VoidCastedCallStatementSyntax(const VoidCastedCallStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ProceduralAssignStatementSyntax : public StatementSyntax {
    Token keyword;
    not_null<ExpressionSyntax*> expr;
    Token semi;

    ProceduralAssignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& expr, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), expr(&expr), semi(semi) {
        this->expr->parent = this;
    }

    explicit ProceduralAssignStatementSyntax(const ProceduralAssignStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ProceduralDeassignStatementSyntax : public StatementSyntax {
    Token keyword;
    not_null<ExpressionSyntax*> variable;
    Token semi;

    ProceduralDeassignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& variable, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), variable(&variable), semi(semi) {
        this->variable->parent = this;
    }

    explicit ProceduralDeassignStatementSyntax(const ProceduralDeassignStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DisableStatementSyntax : public StatementSyntax {
    Token disable;
    not_null<NameSyntax*> name;
    Token semi;

    DisableStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, NameSyntax& name, Token semi) :
        StatementSyntax(SyntaxKind::DisableStatement, label, attributes), disable(disable), name(&name), semi(semi) {
        this->name->parent = this;
    }

    explicit DisableStatementSyntax(const DisableStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DisableForkStatementSyntax : public StatementSyntax {
    Token disable;
    Token fork;
    Token semi;

    DisableForkStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::DisableForkStatement, label, attributes), disable(disable), fork(fork), semi(semi) {
    }

    explicit DisableForkStatementSyntax(const DisableForkStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NamedBlockClauseSyntax : public SyntaxNode {
    Token colon;
    Token name;

    NamedBlockClauseSyntax(Token colon, Token name) :
        SyntaxNode(SyntaxKind::NamedBlockClause), colon(colon), name(name) {
    }

    explicit NamedBlockClauseSyntax(const NamedBlockClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BlockStatementSyntax : public StatementSyntax {
    Token begin;
    NamedBlockClauseSyntax* blockName;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    BlockStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token begin, NamedBlockClauseSyntax* blockName, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName) :
        StatementSyntax(kind, label, attributes), begin(begin), blockName(blockName), items(items), end(end), endBlockName(endBlockName) {
        if (this->blockName) this->blockName->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    explicit BlockStatementSyntax(const BlockStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT WaitStatementSyntax : public StatementSyntax {
    Token wait;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    not_null<StatementSyntax*> statement;

    WaitStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::WaitStatement, label, attributes), wait(wait), openParen(openParen), expr(&expr), closeParen(closeParen), statement(&statement) {
        this->expr->parent = this;
        this->statement->parent = this;
    }

    explicit WaitStatementSyntax(const WaitStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT WaitForkStatementSyntax : public StatementSyntax {
    Token wait;
    Token fork;
    Token semi;

    WaitForkStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::WaitForkStatement, label, attributes), wait(wait), fork(fork), semi(semi) {
    }

    explicit WaitForkStatementSyntax(const WaitForkStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT WaitOrderStatementSyntax : public StatementSyntax {
    Token wait_order;
    Token openParen;
    SeparatedSyntaxList<NameSyntax> names;
    Token closeParen;
    not_null<ActionBlockSyntax*> action;

    WaitOrderStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait_order, Token openParen, const SeparatedSyntaxList<NameSyntax>& names, Token closeParen, ActionBlockSyntax& action) :
        StatementSyntax(SyntaxKind::WaitOrderStatement, label, attributes), wait_order(wait_order), openParen(openParen), names(names), closeParen(closeParen), action(&action) {
        this->names.parent = this;
        for (auto child : this->names)
            child->parent = this;
        this->action->parent = this;
    }

    explicit WaitOrderStatementSyntax(const WaitOrderStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RandCaseItemSyntax : public SyntaxNode {
    not_null<ExpressionSyntax*> expr;
    Token colon;
    not_null<StatementSyntax*> statement;

    RandCaseItemSyntax(ExpressionSyntax& expr, Token colon, StatementSyntax& statement) :
        SyntaxNode(SyntaxKind::RandCaseItem), expr(&expr), colon(colon), statement(&statement) {
        this->expr->parent = this;
        this->statement->parent = this;
    }

    explicit RandCaseItemSyntax(const RandCaseItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RandCaseStatementSyntax : public StatementSyntax {
    Token randCase;
    SyntaxList<RandCaseItemSyntax> items;
    Token endCase;

    RandCaseStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token randCase, const SyntaxList<RandCaseItemSyntax>& items, Token endCase) :
        StatementSyntax(SyntaxKind::RandCaseStatement, label, attributes), randCase(randCase), items(items), endCase(endCase) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit RandCaseStatementSyntax(const RandCaseStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RsProdSyntax : public SyntaxNode {

    RsProdSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit RsProdSyntax(const RsProdSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT RsProdItemSyntax : public RsProdSyntax {
    Token name;
    ArgumentListSyntax* argList;

    RsProdItemSyntax(Token name, ArgumentListSyntax* argList) :
        RsProdSyntax(SyntaxKind::RsProdItem), name(name), argList(argList) {
        if (this->argList) this->argList->parent = this;
    }

    explicit RsProdItemSyntax(const RsProdItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RsCodeBlockSyntax : public RsProdSyntax {
    Token openBrace;
    SyntaxList<SyntaxNode> items;
    Token closeBrace;

    RsCodeBlockSyntax(Token openBrace, const SyntaxList<SyntaxNode>& items, Token closeBrace) :
        RsProdSyntax(SyntaxKind::RsCodeBlock), openBrace(openBrace), items(items), closeBrace(closeBrace) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit RsCodeBlockSyntax(const RsCodeBlockSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RsElseClauseSyntax : public SyntaxNode {
    Token keyword;
    not_null<RsProdItemSyntax*> item;

    RsElseClauseSyntax(Token keyword, RsProdItemSyntax& item) :
        SyntaxNode(SyntaxKind::RsElseClause), keyword(keyword), item(&item) {
        this->item->parent = this;
    }

    explicit RsElseClauseSyntax(const RsElseClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RsIfElseSyntax : public RsProdSyntax {
    Token keyword;
    Token openParen;
    not_null<ExpressionSyntax*> condition;
    Token closeParen;
    not_null<RsProdItemSyntax*> ifItem;
    RsElseClauseSyntax* elseClause;

    RsIfElseSyntax(Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, RsProdItemSyntax& ifItem, RsElseClauseSyntax* elseClause) :
        RsProdSyntax(SyntaxKind::RsIfElse), keyword(keyword), openParen(openParen), condition(&condition), closeParen(closeParen), ifItem(&ifItem), elseClause(elseClause) {
        this->condition->parent = this;
        this->ifItem->parent = this;
        if (this->elseClause) this->elseClause->parent = this;
    }

    explicit RsIfElseSyntax(const RsIfElseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RsRepeatSyntax : public RsProdSyntax {
    Token keyword;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    not_null<RsProdItemSyntax*> item;

    RsRepeatSyntax(Token keyword, Token openParen, ExpressionSyntax& expr, Token closeParen, RsProdItemSyntax& item) :
        RsProdSyntax(SyntaxKind::RsRepeat), keyword(keyword), openParen(openParen), expr(&expr), closeParen(closeParen), item(&item) {
        this->expr->parent = this;
        this->item->parent = this;
    }

    explicit RsRepeatSyntax(const RsRepeatSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RsCaseItemSyntax : public SyntaxNode {

    RsCaseItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit RsCaseItemSyntax(const RsCaseItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT DefaultRsCaseItemSyntax : public RsCaseItemSyntax {
    Token defaultKeyword;
    Token colon;
    not_null<RsProdItemSyntax*> item;
    Token semi;

    DefaultRsCaseItemSyntax(Token defaultKeyword, Token colon, RsProdItemSyntax& item, Token semi) :
        RsCaseItemSyntax(SyntaxKind::DefaultRsCaseItem), defaultKeyword(defaultKeyword), colon(colon), item(&item), semi(semi) {
        this->item->parent = this;
    }

    explicit DefaultRsCaseItemSyntax(const DefaultRsCaseItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StandardRsCaseItemSyntax : public RsCaseItemSyntax {
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token colon;
    not_null<RsProdItemSyntax*> item;
    Token semi;

    StandardRsCaseItemSyntax(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, RsProdItemSyntax& item, Token semi) :
        RsCaseItemSyntax(SyntaxKind::StandardRsCaseItem), expressions(expressions), colon(colon), item(&item), semi(semi) {
        this->expressions.parent = this;
        for (auto child : this->expressions)
            child->parent = this;
        this->item->parent = this;
    }

    explicit StandardRsCaseItemSyntax(const StandardRsCaseItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RsCaseSyntax : public RsProdSyntax {
    Token keyword;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    SyntaxList<RsCaseItemSyntax> items;
    Token endcase;

    RsCaseSyntax(Token keyword, Token openParen, ExpressionSyntax& expr, Token closeParen, const SyntaxList<RsCaseItemSyntax>& items, Token endcase) :
        RsProdSyntax(SyntaxKind::RsCase), keyword(keyword), openParen(openParen), expr(&expr), closeParen(closeParen), items(items), endcase(endcase) {
        this->expr->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit RsCaseSyntax(const RsCaseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RandJoinClauseSyntax : public SyntaxNode {
    Token rand;
    Token join;
    ParenthesizedExpressionSyntax* expr;

    RandJoinClauseSyntax(Token rand, Token join, ParenthesizedExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::RandJoinClause), rand(rand), join(join), expr(expr) {
        if (this->expr) this->expr->parent = this;
    }

    explicit RandJoinClauseSyntax(const RandJoinClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RsWeightClauseSyntax : public SyntaxNode {
    Token colonEqual;
    not_null<ExpressionSyntax*> weight;
    RsProdSyntax* codeBlock;

    RsWeightClauseSyntax(Token colonEqual, ExpressionSyntax& weight, RsProdSyntax* codeBlock) :
        SyntaxNode(SyntaxKind::RsWeightClause), colonEqual(colonEqual), weight(&weight), codeBlock(codeBlock) {
        this->weight->parent = this;
        if (this->codeBlock) this->codeBlock->parent = this;
    }

    explicit RsWeightClauseSyntax(const RsWeightClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RsRuleSyntax : public SyntaxNode {
    RandJoinClauseSyntax* randJoin;
    SyntaxList<RsProdSyntax> prods;
    RsWeightClauseSyntax* weightClause;

    RsRuleSyntax(RandJoinClauseSyntax* randJoin, const SyntaxList<RsProdSyntax>& prods, RsWeightClauseSyntax* weightClause) :
        SyntaxNode(SyntaxKind::RsRule), randJoin(randJoin), prods(prods), weightClause(weightClause) {
        if (this->randJoin) this->randJoin->parent = this;
        this->prods.parent = this;
        for (auto child : this->prods)
            child->parent = this;
        if (this->weightClause) this->weightClause->parent = this;
    }

    explicit RsRuleSyntax(const RsRuleSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ProductionSyntax : public SyntaxNode {
    DataTypeSyntax* dataType;
    Token name;
    FunctionPortListSyntax* portList;
    Token colon;
    SeparatedSyntaxList<RsRuleSyntax> rules;
    Token semi;

    ProductionSyntax(DataTypeSyntax* dataType, Token name, FunctionPortListSyntax* portList, Token colon, const SeparatedSyntaxList<RsRuleSyntax>& rules, Token semi) :
        SyntaxNode(SyntaxKind::Production), dataType(dataType), name(name), portList(portList), colon(colon), rules(rules), semi(semi) {
        if (this->dataType) this->dataType->parent = this;
        if (this->portList) this->portList->parent = this;
        this->rules.parent = this;
        for (auto child : this->rules)
            child->parent = this;
    }

    explicit ProductionSyntax(const ProductionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RandSequenceStatementSyntax : public StatementSyntax {
    Token randsequence;
    Token openParen;
    Token firstProduction;
    Token closeParen;
    SyntaxList<ProductionSyntax> productions;
    Token endsequence;

    RandSequenceStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token randsequence, Token openParen, Token firstProduction, Token closeParen, const SyntaxList<ProductionSyntax>& productions, Token endsequence) :
        StatementSyntax(SyntaxKind::RandSequenceStatement, label, attributes), randsequence(randsequence), openParen(openParen), firstProduction(firstProduction), closeParen(closeParen), productions(productions), endsequence(endsequence) {
        this->productions.parent = this;
        for (auto child : this->productions)
            child->parent = this;
    }

    explicit RandSequenceStatementSyntax(const RandSequenceStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EventTriggerStatementSyntax : public StatementSyntax {
    Token trigger;
    TimingControlSyntax* timing;
    not_null<NameSyntax*> name;
    Token semi;

    EventTriggerStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name, Token semi) :
        StatementSyntax(kind, label, attributes), trigger(trigger), timing(timing), name(&name), semi(semi) {
        if (this->timing) this->timing->parent = this;
        this->name->parent = this;
    }

    explicit EventTriggerStatementSyntax(const EventTriggerStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PortListSyntax : public SyntaxNode {

    PortListSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit PortListSyntax(const PortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT NonAnsiPortSyntax : public SyntaxNode {

    NonAnsiPortSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit NonAnsiPortSyntax(const NonAnsiPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT PortExpressionSyntax : public SyntaxNode {

    PortExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit PortExpressionSyntax(const PortExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT PortReferenceSyntax : public PortExpressionSyntax {
    Token name;
    ElementSelectSyntax* select;

    PortReferenceSyntax(Token name, ElementSelectSyntax* select) :
        PortExpressionSyntax(SyntaxKind::PortReference), name(name), select(select) {
        if (this->select) this->select->parent = this;
    }

    explicit PortReferenceSyntax(const PortReferenceSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PortConcatenationSyntax : public PortExpressionSyntax {
    Token openBrace;
    SeparatedSyntaxList<PortReferenceSyntax> references;
    Token closeBrace;

    PortConcatenationSyntax(Token openBrace, const SeparatedSyntaxList<PortReferenceSyntax>& references, Token closeBrace) :
        PortExpressionSyntax(SyntaxKind::PortConcatenation), openBrace(openBrace), references(references), closeBrace(closeBrace) {
        this->references.parent = this;
        for (auto child : this->references)
            child->parent = this;
    }

    explicit PortConcatenationSyntax(const PortConcatenationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EmptyNonAnsiPortSyntax : public NonAnsiPortSyntax {
    Token placeholder;

    EmptyNonAnsiPortSyntax(Token placeholder) :
        NonAnsiPortSyntax(SyntaxKind::EmptyNonAnsiPort), placeholder(placeholder) {
    }

    explicit EmptyNonAnsiPortSyntax(const EmptyNonAnsiPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ImplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    not_null<PortExpressionSyntax*> expr;

    ImplicitNonAnsiPortSyntax(PortExpressionSyntax& expr) :
        NonAnsiPortSyntax(SyntaxKind::ImplicitNonAnsiPort), expr(&expr) {
        this->expr->parent = this;
    }

    explicit ImplicitNonAnsiPortSyntax(const ImplicitNonAnsiPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    Token dot;
    Token name;
    Token openParen;
    PortExpressionSyntax* expr;
    Token closeParen;

    ExplicitNonAnsiPortSyntax(Token dot, Token name, Token openParen, PortExpressionSyntax* expr, Token closeParen) :
        NonAnsiPortSyntax(SyntaxKind::ExplicitNonAnsiPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
        if (this->expr) this->expr->parent = this;
    }

    explicit ExplicitNonAnsiPortSyntax(const ExplicitNonAnsiPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NonAnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<NonAnsiPortSyntax> ports;
    Token closeParen;

    NonAnsiPortListSyntax(Token openParen, const SeparatedSyntaxList<NonAnsiPortSyntax>& ports, Token closeParen) :
        PortListSyntax(SyntaxKind::NonAnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    explicit NonAnsiPortListSyntax(const NonAnsiPortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT InterfacePortHeaderSyntax : public PortHeaderSyntax {
    Token nameOrKeyword;
    DotMemberClauseSyntax* modport;

    InterfacePortHeaderSyntax(Token nameOrKeyword, DotMemberClauseSyntax* modport) :
        PortHeaderSyntax(SyntaxKind::InterfacePortHeader), nameOrKeyword(nameOrKeyword), modport(modport) {
        if (this->modport) this->modport->parent = this;
    }

    explicit InterfacePortHeaderSyntax(const InterfacePortHeaderSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT VariablePortHeaderSyntax : public PortHeaderSyntax {
    Token constKeyword;
    Token direction;
    Token varKeyword;
    not_null<DataTypeSyntax*> dataType;

    VariablePortHeaderSyntax(Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax& dataType) :
        PortHeaderSyntax(SyntaxKind::VariablePortHeader), constKeyword(constKeyword), direction(direction), varKeyword(varKeyword), dataType(&dataType) {
        this->dataType->parent = this;
    }

    explicit VariablePortHeaderSyntax(const VariablePortHeaderSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NetPortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token netType;
    not_null<DataTypeSyntax*> dataType;

    NetPortHeaderSyntax(Token direction, Token netType, DataTypeSyntax& dataType) :
        PortHeaderSyntax(SyntaxKind::NetPortHeader), direction(direction), netType(netType), dataType(&dataType) {
        this->dataType->parent = this;
    }

    explicit NetPortHeaderSyntax(const NetPortHeaderSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ImplicitAnsiPortSyntax : public MemberSyntax {
    not_null<PortHeaderSyntax*> header;
    not_null<DeclaratorSyntax*> declarator;

    ImplicitAnsiPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, DeclaratorSyntax& declarator) :
        MemberSyntax(SyntaxKind::ImplicitAnsiPort, attributes), header(&header), declarator(&declarator) {
        this->header->parent = this;
        this->declarator->parent = this;
    }

    explicit ImplicitAnsiPortSyntax(const ImplicitAnsiPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExplicitAnsiPortSyntax : public MemberSyntax {
    Token direction;
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ExplicitAnsiPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        MemberSyntax(SyntaxKind::ExplicitAnsiPort, attributes), direction(direction), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
        if (this->expr) this->expr->parent = this;
    }

    explicit ExplicitAnsiPortSyntax(const ExplicitAnsiPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT AnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<MemberSyntax> ports;
    Token closeParen;

    AnsiPortListSyntax(Token openParen, const SeparatedSyntaxList<MemberSyntax>& ports, Token closeParen) :
        PortListSyntax(SyntaxKind::AnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    explicit AnsiPortListSyntax(const AnsiPortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT WildcardPortListSyntax : public PortListSyntax {
    Token openParen;
    Token dot;
    Token star;
    Token closeParen;

    WildcardPortListSyntax(Token openParen, Token dot, Token star, Token closeParen) :
        PortListSyntax(SyntaxKind::WildcardPortList), openParen(openParen), dot(dot), star(star), closeParen(closeParen) {
    }

    explicit WildcardPortListSyntax(const WildcardPortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParameterPortListSyntax : public SyntaxNode {
    Token hash;
    Token openParen;
    SeparatedSyntaxList<ParameterDeclarationBaseSyntax> declarations;
    Token closeParen;

    ParameterPortListSyntax(Token hash, Token openParen, const SeparatedSyntaxList<ParameterDeclarationBaseSyntax>& declarations, Token closeParen) :
        SyntaxNode(SyntaxKind::ParameterPortList), hash(hash), openParen(openParen), declarations(declarations), closeParen(closeParen) {
        this->declarations.parent = this;
        for (auto child : this->declarations)
            child->parent = this;
    }

    explicit ParameterPortListSyntax(const ParameterPortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ModuleHeaderSyntax : public SyntaxNode {
    Token moduleKeyword;
    Token lifetime;
    Token name;
    SyntaxList<PackageImportDeclarationSyntax> imports;
    ParameterPortListSyntax* parameters;
    PortListSyntax* ports;
    Token semi;

    ModuleHeaderSyntax(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, const SyntaxList<PackageImportDeclarationSyntax>& imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi) :
        SyntaxNode(kind), moduleKeyword(moduleKeyword), lifetime(lifetime), name(name), imports(imports), parameters(parameters), ports(ports), semi(semi) {
        this->imports.parent = this;
        for (auto child : this->imports)
            child->parent = this;
        if (this->parameters) this->parameters->parent = this;
        if (this->ports) this->ports->parent = this;
    }

    explicit ModuleHeaderSyntax(const ModuleHeaderSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ModuleDeclarationSyntax : public MemberSyntax {
    not_null<ModuleHeaderSyntax*> header;
    SyntaxList<MemberSyntax> members;
    Token endmodule;
    NamedBlockClauseSyntax* blockName;

    ModuleDeclarationSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, ModuleHeaderSyntax& header, const SyntaxList<MemberSyntax>& members, Token endmodule, NamedBlockClauseSyntax* blockName) :
        MemberSyntax(kind, attributes), header(&header), members(members), endmodule(endmodule), blockName(blockName) {
        this->header->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
        if (this->blockName) this->blockName->parent = this;
    }

    explicit ModuleDeclarationSyntax(const ModuleDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT AnonymousProgramSyntax : public MemberSyntax {
    Token keyword;
    Token semi;
    SyntaxList<MemberSyntax> members;
    Token endkeyword;

    AnonymousProgramSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token semi, const SyntaxList<MemberSyntax>& members, Token endkeyword) :
        MemberSyntax(SyntaxKind::AnonymousProgram, attributes), keyword(keyword), semi(semi), members(members), endkeyword(endkeyword) {
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
    }

    explicit AnonymousProgramSyntax(const AnonymousProgramSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EmptyMemberSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token semi;

    EmptyMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token semi) :
        MemberSyntax(SyntaxKind::EmptyMember, attributes), qualifiers(qualifiers), semi(semi) {
        this->qualifiers.parent = this;
    }

    explicit EmptyMemberSyntax(const EmptyMemberSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ProceduralBlockSyntax : public MemberSyntax {
    Token keyword;
    not_null<StatementSyntax*> statement;

    ProceduralBlockSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, StatementSyntax& statement) :
        MemberSyntax(kind, attributes), keyword(keyword), statement(&statement) {
        this->statement->parent = this;
    }

    explicit ProceduralBlockSyntax(const ProceduralBlockSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT GenerateRegionSyntax : public MemberSyntax {
    Token keyword;
    SyntaxList<MemberSyntax> members;
    Token endgenerate;

    GenerateRegionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SyntaxList<MemberSyntax>& members, Token endgenerate) :
        MemberSyntax(SyntaxKind::GenerateRegion, attributes), keyword(keyword), members(members), endgenerate(endgenerate) {
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
    }

    explicit GenerateRegionSyntax(const GenerateRegionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT LoopGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    Token genvar;
    Token identifier;
    Token equals;
    not_null<ExpressionSyntax*> initialExpr;
    Token semi1;
    not_null<ExpressionSyntax*> stopExpr;
    Token semi2;
    not_null<ExpressionSyntax*> iterationExpr;
    Token closeParen;
    not_null<MemberSyntax*> block;

    LoopGenerateSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block) :
        MemberSyntax(SyntaxKind::LoopGenerate, attributes), keyword(keyword), openParen(openParen), genvar(genvar), identifier(identifier), equals(equals), initialExpr(&initialExpr), semi1(semi1), stopExpr(&stopExpr), semi2(semi2), iterationExpr(&iterationExpr), closeParen(closeParen), block(&block) {
        this->initialExpr->parent = this;
        this->stopExpr->parent = this;
        this->iterationExpr->parent = this;
        this->block->parent = this;
    }

    explicit LoopGenerateSyntax(const LoopGenerateSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT IfGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    not_null<ExpressionSyntax*> condition;
    Token closeParen;
    not_null<MemberSyntax*> block;
    ElseClauseSyntax* elseClause;

    IfGenerateSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause) :
        MemberSyntax(SyntaxKind::IfGenerate, attributes), keyword(keyword), openParen(openParen), condition(&condition), closeParen(closeParen), block(&block), elseClause(elseClause) {
        this->condition->parent = this;
        this->block->parent = this;
        if (this->elseClause) this->elseClause->parent = this;
    }

    explicit IfGenerateSyntax(const IfGenerateSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CaseGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    not_null<ExpressionSyntax*> condition;
    Token closeParen;
    SyntaxList<CaseItemSyntax> items;
    Token endCase;

    CaseGenerateSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, const SyntaxList<CaseItemSyntax>& items, Token endCase) :
        MemberSyntax(SyntaxKind::CaseGenerate, attributes), keyword(keyword), openParen(openParen), condition(&condition), closeParen(closeParen), items(items), endCase(endCase) {
        this->condition->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit CaseGenerateSyntax(const CaseGenerateSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT GenerateBlockSyntax : public MemberSyntax {
    NamedLabelSyntax* label;
    Token begin;
    NamedBlockClauseSyntax* beginName;
    SyntaxList<MemberSyntax> members;
    Token end;
    NamedBlockClauseSyntax* endName;

    GenerateBlockSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, const SyntaxList<MemberSyntax>& members, Token end, NamedBlockClauseSyntax* endName) :
        MemberSyntax(SyntaxKind::GenerateBlock, attributes), label(label), begin(begin), beginName(beginName), members(members), end(end), endName(endName) {
        if (this->label) this->label->parent = this;
        if (this->beginName) this->beginName->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
        if (this->endName) this->endName->parent = this;
    }

    explicit GenerateBlockSyntax(const GenerateBlockSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DividerClauseSyntax : public SyntaxNode {
    Token divide;
    Token value;

    DividerClauseSyntax(Token divide, Token value) :
        SyntaxNode(SyntaxKind::DividerClause), divide(divide), value(value) {
    }

    explicit DividerClauseSyntax(const DividerClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TimeUnitsDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token time;
    DividerClauseSyntax* divider;
    Token semi;

    TimeUnitsDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi) :
        MemberSyntax(SyntaxKind::TimeUnitsDeclaration, attributes), keyword(keyword), time(time), divider(divider), semi(semi) {
        if (this->divider) this->divider->parent = this;
    }

    explicit TimeUnitsDeclarationSyntax(const TimeUnitsDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PortConnectionSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    PortConnectionSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes) :
        SyntaxNode(kind), attributes(attributes) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
    }

    explicit PortConnectionSyntax(const PortConnectionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EmptyPortConnectionSyntax : public PortConnectionSyntax {
    Token placeholder;

    EmptyPortConnectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token placeholder) :
        PortConnectionSyntax(SyntaxKind::EmptyPortConnection, attributes), placeholder(placeholder) {
    }

    explicit EmptyPortConnectionSyntax(const EmptyPortConnectionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT OrderedPortConnectionSyntax : public PortConnectionSyntax {
    not_null<PropertyExprSyntax*> expr;

    OrderedPortConnectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, PropertyExprSyntax& expr) :
        PortConnectionSyntax(SyntaxKind::OrderedPortConnection, attributes), expr(&expr) {
        this->expr->parent = this;
    }

    explicit OrderedPortConnectionSyntax(const OrderedPortConnectionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NamedPortConnectionSyntax : public PortConnectionSyntax {
    Token dot;
    Token name;
    Token openParen;
    PropertyExprSyntax* expr;
    Token closeParen;

    NamedPortConnectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dot, Token name, Token openParen, PropertyExprSyntax* expr, Token closeParen) :
        PortConnectionSyntax(SyntaxKind::NamedPortConnection, attributes), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
        if (this->expr) this->expr->parent = this;
    }

    explicit NamedPortConnectionSyntax(const NamedPortConnectionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT WildcardPortConnectionSyntax : public PortConnectionSyntax {
    Token dot;
    Token star;

    WildcardPortConnectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dot, Token star) :
        PortConnectionSyntax(SyntaxKind::WildcardPortConnection, attributes), dot(dot), star(star) {
    }

    explicit WildcardPortConnectionSyntax(const WildcardPortConnectionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT InstanceNameSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;

    InstanceNameSyntax(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions) :
        SyntaxNode(SyntaxKind::InstanceName), name(name), dimensions(dimensions) {
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
    }

    explicit InstanceNameSyntax(const InstanceNameSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT HierarchicalInstanceSyntax : public SyntaxNode {
    InstanceNameSyntax* decl;
    Token openParen;
    SeparatedSyntaxList<PortConnectionSyntax> connections;
    Token closeParen;

    HierarchicalInstanceSyntax(InstanceNameSyntax* decl, Token openParen, const SeparatedSyntaxList<PortConnectionSyntax>& connections, Token closeParen) :
        SyntaxNode(SyntaxKind::HierarchicalInstance), decl(decl), openParen(openParen), connections(connections), closeParen(closeParen) {
        if (this->decl) this->decl->parent = this;
        this->connections.parent = this;
        for (auto child : this->connections)
            child->parent = this;
    }

    explicit HierarchicalInstanceSyntax(const HierarchicalInstanceSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT HierarchyInstantiationSyntax : public MemberSyntax {
    Token type;
    ParameterValueAssignmentSyntax* parameters;
    SeparatedSyntaxList<HierarchicalInstanceSyntax> instances;
    Token semi;

    HierarchyInstantiationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token type, ParameterValueAssignmentSyntax* parameters, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi) :
        MemberSyntax(SyntaxKind::HierarchyInstantiation, attributes), type(type), parameters(parameters), instances(instances), semi(semi) {
        if (this->parameters) this->parameters->parent = this;
        this->instances.parent = this;
        for (auto child : this->instances)
            child->parent = this;
    }

    explicit HierarchyInstantiationSyntax(const HierarchyInstantiationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PrimitiveInstantiationSyntax : public MemberSyntax {
    Token type;
    NetStrengthSyntax* strength;
    TimingControlSyntax* delay;
    SeparatedSyntaxList<HierarchicalInstanceSyntax> instances;
    Token semi;

    PrimitiveInstantiationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token type, NetStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi) :
        MemberSyntax(SyntaxKind::PrimitiveInstantiation, attributes), type(type), strength(strength), delay(delay), instances(instances), semi(semi) {
        if (this->strength) this->strength->parent = this;
        if (this->delay) this->delay->parent = this;
        this->instances.parent = this;
        for (auto child : this->instances)
            child->parent = this;
    }

    explicit PrimitiveInstantiationSyntax(const PrimitiveInstantiationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CheckerInstantiationSyntax : public MemberSyntax {
    not_null<NameSyntax*> type;
    ParameterValueAssignmentSyntax* parameters;
    SeparatedSyntaxList<HierarchicalInstanceSyntax> instances;
    Token semi;

    CheckerInstantiationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, NameSyntax& type, ParameterValueAssignmentSyntax* parameters, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi) :
        MemberSyntax(SyntaxKind::CheckerInstantiation, attributes), type(&type), parameters(parameters), instances(instances), semi(semi) {
        this->type->parent = this;
        if (this->parameters) this->parameters->parent = this;
        this->instances.parent = this;
        for (auto child : this->instances)
            child->parent = this;
    }

    explicit CheckerInstantiationSyntax(const CheckerInstantiationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CheckerInstanceStatementSyntax : public StatementSyntax {
    not_null<CheckerInstantiationSyntax*> instance;

    CheckerInstanceStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, CheckerInstantiationSyntax& instance) :
        StatementSyntax(SyntaxKind::CheckerInstanceStatement, label, attributes), instance(&instance) {
        this->instance->parent = this;
    }

    explicit CheckerInstanceStatementSyntax(const CheckerInstanceStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BindTargetListSyntax : public SyntaxNode {
    Token colon;
    SeparatedSyntaxList<NameSyntax> targets;

    BindTargetListSyntax(Token colon, const SeparatedSyntaxList<NameSyntax>& targets) :
        SyntaxNode(SyntaxKind::BindTargetList), colon(colon), targets(targets) {
        this->targets.parent = this;
        for (auto child : this->targets)
            child->parent = this;
    }

    explicit BindTargetListSyntax(const BindTargetListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BindDirectiveSyntax : public MemberSyntax {
    Token bind;
    not_null<NameSyntax*> target;
    BindTargetListSyntax* targetInstances;
    not_null<MemberSyntax*> instantiation;

    BindDirectiveSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token bind, NameSyntax& target, BindTargetListSyntax* targetInstances, MemberSyntax& instantiation) :
        MemberSyntax(SyntaxKind::BindDirective, attributes), bind(bind), target(&target), targetInstances(targetInstances), instantiation(&instantiation) {
        this->target->parent = this;
        if (this->targetInstances) this->targetInstances->parent = this;
        this->instantiation->parent = this;
    }

    explicit BindDirectiveSyntax(const BindDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClassSpecifierSyntax : public SyntaxNode {
    Token colon;
    Token keyword;

    ClassSpecifierSyntax(Token colon, Token keyword) :
        SyntaxNode(SyntaxKind::ClassSpecifier), colon(colon), keyword(keyword) {
    }

    explicit ClassSpecifierSyntax(const ClassSpecifierSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT FunctionPrototypeSyntax : public SyntaxNode {
    Token keyword;
    SyntaxList<ClassSpecifierSyntax> specifiers;
    Token lifetime;
    not_null<DataTypeSyntax*> returnType;
    not_null<NameSyntax*> name;
    FunctionPortListSyntax* portList;

    FunctionPrototypeSyntax(Token keyword, const SyntaxList<ClassSpecifierSyntax>& specifiers, Token lifetime, DataTypeSyntax& returnType, NameSyntax& name, FunctionPortListSyntax* portList) :
        SyntaxNode(SyntaxKind::FunctionPrototype), keyword(keyword), specifiers(specifiers), lifetime(lifetime), returnType(&returnType), name(&name), portList(portList) {
        this->specifiers.parent = this;
        for (auto child : this->specifiers)
            child->parent = this;
        this->returnType->parent = this;
        this->name->parent = this;
        if (this->portList) this->portList->parent = this;
    }

    explicit FunctionPrototypeSyntax(const FunctionPrototypeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT FunctionDeclarationSyntax : public MemberSyntax {
    not_null<FunctionPrototypeSyntax*> prototype;
    Token semi;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    FunctionDeclarationSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, FunctionPrototypeSyntax& prototype, Token semi, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(kind, attributes), prototype(&prototype), semi(semi), items(items), end(end), endBlockName(endBlockName) {
        this->prototype->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    explicit FunctionDeclarationSyntax(const FunctionDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EqualsAssertionArgClauseSyntax : public SyntaxNode {
    Token equals;
    not_null<PropertyExprSyntax*> expr;

    EqualsAssertionArgClauseSyntax(Token equals, PropertyExprSyntax& expr) :
        SyntaxNode(SyntaxKind::EqualsAssertionArgClause), equals(equals), expr(&expr) {
        this->expr->parent = this;
    }

    explicit EqualsAssertionArgClauseSyntax(const EqualsAssertionArgClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT AssertionItemPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token local;
    Token direction;
    not_null<DataTypeSyntax*> type;
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    EqualsAssertionArgClauseSyntax* defaultValue;

    AssertionItemPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token local, Token direction, DataTypeSyntax& type, Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, EqualsAssertionArgClauseSyntax* defaultValue) :
        SyntaxNode(SyntaxKind::AssertionItemPort), attributes(attributes), local(local), direction(direction), type(&type), name(name), dimensions(dimensions), defaultValue(defaultValue) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        this->type->parent = this;
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
        if (this->defaultValue) this->defaultValue->parent = this;
    }

    explicit AssertionItemPortSyntax(const AssertionItemPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT AssertionItemPortListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<AssertionItemPortSyntax> ports;
    Token closeParen;

    AssertionItemPortListSyntax(Token openParen, const SeparatedSyntaxList<AssertionItemPortSyntax>& ports, Token closeParen) :
        SyntaxNode(SyntaxKind::AssertionItemPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    explicit AssertionItemPortListSyntax(const AssertionItemPortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT LetDeclarationSyntax : public MemberSyntax {
    Token let;
    Token identifier;
    AssertionItemPortListSyntax* portList;
    Token equals;
    not_null<ExpressionSyntax*> expr;
    Token semi;

    LetDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, Token equals, ExpressionSyntax& expr, Token semi) :
        MemberSyntax(SyntaxKind::LetDeclaration, attributes), let(let), identifier(identifier), portList(portList), equals(equals), expr(&expr), semi(semi) {
        if (this->portList) this->portList->parent = this;
        this->expr->parent = this;
    }

    explicit LetDeclarationSyntax(const LetDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DefaultExtendsClauseArgSyntax : public SyntaxNode {
    Token openParen;
    Token defaultKeyword;
    Token closeParen;

    DefaultExtendsClauseArgSyntax(Token openParen, Token defaultKeyword, Token closeParen) :
        SyntaxNode(SyntaxKind::DefaultExtendsClauseArg), openParen(openParen), defaultKeyword(defaultKeyword), closeParen(closeParen) {
    }

    explicit DefaultExtendsClauseArgSyntax(const DefaultExtendsClauseArgSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExtendsClauseSyntax : public SyntaxNode {
    Token keyword;
    not_null<NameSyntax*> baseName;
    ArgumentListSyntax* arguments;
    DefaultExtendsClauseArgSyntax* defaultedArg;

    ExtendsClauseSyntax(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments, DefaultExtendsClauseArgSyntax* defaultedArg) :
        SyntaxNode(SyntaxKind::ExtendsClause), keyword(keyword), baseName(&baseName), arguments(arguments), defaultedArg(defaultedArg) {
        this->baseName->parent = this;
        if (this->arguments) this->arguments->parent = this;
        if (this->defaultedArg) this->defaultedArg->parent = this;
    }

    explicit ExtendsClauseSyntax(const ExtendsClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ImplementsClauseSyntax : public SyntaxNode {
    Token keyword;
    SeparatedSyntaxList<NameSyntax> interfaces;

    ImplementsClauseSyntax(Token keyword, const SeparatedSyntaxList<NameSyntax>& interfaces) :
        SyntaxNode(SyntaxKind::ImplementsClause), keyword(keyword), interfaces(interfaces) {
        this->interfaces.parent = this;
        for (auto child : this->interfaces)
            child->parent = this;
    }

    explicit ImplementsClauseSyntax(const ImplementsClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClassDeclarationSyntax : public MemberSyntax {
    Token virtualOrInterface;
    Token classKeyword;
    ClassSpecifierSyntax* finalSpecifier;
    Token name;
    ParameterPortListSyntax* parameters;
    ExtendsClauseSyntax* extendsClause;
    ImplementsClauseSyntax* implementsClause;
    Token semi;
    SyntaxList<MemberSyntax> items;
    Token endClass;
    NamedBlockClauseSyntax* endBlockName;

    ClassDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token virtualOrInterface, Token classKeyword, ClassSpecifierSyntax* finalSpecifier, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, const SyntaxList<MemberSyntax>& items, Token endClass, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::ClassDeclaration, attributes), virtualOrInterface(virtualOrInterface), classKeyword(classKeyword), finalSpecifier(finalSpecifier), name(name), parameters(parameters), extendsClause(extendsClause), implementsClause(implementsClause), semi(semi), items(items), endClass(endClass), endBlockName(endBlockName) {
        if (this->finalSpecifier) this->finalSpecifier->parent = this;
        if (this->parameters) this->parameters->parent = this;
        if (this->extendsClause) this->extendsClause->parent = this;
        if (this->implementsClause) this->implementsClause->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    explicit ClassDeclarationSyntax(const ClassDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClassPropertyDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    not_null<MemberSyntax*> declaration;

    ClassPropertyDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, MemberSyntax& declaration) :
        MemberSyntax(SyntaxKind::ClassPropertyDeclaration, attributes), qualifiers(qualifiers), declaration(&declaration) {
        this->qualifiers.parent = this;
        this->declaration->parent = this;
    }

    explicit ClassPropertyDeclarationSyntax(const ClassPropertyDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClassMethodDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    not_null<FunctionDeclarationSyntax*> declaration;

    ClassMethodDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionDeclarationSyntax& declaration) :
        MemberSyntax(SyntaxKind::ClassMethodDeclaration, attributes), qualifiers(qualifiers), declaration(&declaration) {
        this->qualifiers.parent = this;
        this->declaration->parent = this;
    }

    explicit ClassMethodDeclarationSyntax(const ClassMethodDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClassMethodPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    not_null<FunctionPrototypeSyntax*> prototype;
    Token semi;

    ClassMethodPrototypeSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionPrototypeSyntax& prototype, Token semi) :
        MemberSyntax(SyntaxKind::ClassMethodPrototype, attributes), qualifiers(qualifiers), prototype(&prototype), semi(semi) {
        this->qualifiers.parent = this;
        this->prototype->parent = this;
    }

    explicit ClassMethodPrototypeSyntax(const ClassMethodPrototypeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ContinuousAssignSyntax : public MemberSyntax {
    Token assign;
    DriveStrengthSyntax* strength;
    TimingControlSyntax* delay;
    SeparatedSyntaxList<ExpressionSyntax> assignments;
    Token semi;

    ContinuousAssignSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token assign, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<ExpressionSyntax>& assignments, Token semi) :
        MemberSyntax(SyntaxKind::ContinuousAssign, attributes), assign(assign), strength(strength), delay(delay), assignments(assignments), semi(semi) {
        if (this->strength) this->strength->parent = this;
        if (this->delay) this->delay->parent = this;
        this->assignments.parent = this;
        for (auto child : this->assignments)
            child->parent = this;
    }

    explicit ContinuousAssignSyntax(const ContinuousAssignSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DefParamAssignmentSyntax : public SyntaxNode {
    not_null<NameSyntax*> name;
    not_null<EqualsValueClauseSyntax*> setter;

    DefParamAssignmentSyntax(NameSyntax& name, EqualsValueClauseSyntax& setter) :
        SyntaxNode(SyntaxKind::DefParamAssignment), name(&name), setter(&setter) {
        this->name->parent = this;
        this->setter->parent = this;
    }

    explicit DefParamAssignmentSyntax(const DefParamAssignmentSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DefParamSyntax : public MemberSyntax {
    Token defparam;
    SeparatedSyntaxList<DefParamAssignmentSyntax> assignments;
    Token semi;

    DefParamSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defparam, const SeparatedSyntaxList<DefParamAssignmentSyntax>& assignments, Token semi) :
        MemberSyntax(SyntaxKind::DefParam, attributes), defparam(defparam), assignments(assignments), semi(semi) {
        this->assignments.parent = this;
        for (auto child : this->assignments)
            child->parent = this;
    }

    explicit DefParamSyntax(const DefParamSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ModportClockingPortSyntax : public MemberSyntax {
    Token clocking;
    Token name;

    ModportClockingPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token clocking, Token name) :
        MemberSyntax(SyntaxKind::ModportClockingPort, attributes), clocking(clocking), name(name) {
    }

    explicit ModportClockingPortSyntax(const ModportClockingPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ModportPortSyntax : public SyntaxNode {

    ModportPortSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit ModportPortSyntax(const ModportPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT ModportNamedPortSyntax : public ModportPortSyntax {
    Token name;

    ModportNamedPortSyntax(Token name) :
        ModportPortSyntax(SyntaxKind::ModportNamedPort), name(name) {
    }

    explicit ModportNamedPortSyntax(const ModportNamedPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ModportExplicitPortSyntax : public ModportPortSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ModportExplicitPortSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        ModportPortSyntax(SyntaxKind::ModportExplicitPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
        if (this->expr) this->expr->parent = this;
    }

    explicit ModportExplicitPortSyntax(const ModportExplicitPortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ModportSimplePortListSyntax : public MemberSyntax {
    Token direction;
    SeparatedSyntaxList<ModportPortSyntax> ports;

    ModportSimplePortListSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, const SeparatedSyntaxList<ModportPortSyntax>& ports) :
        MemberSyntax(SyntaxKind::ModportSimplePortList, attributes), direction(direction), ports(ports) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    explicit ModportSimplePortListSyntax(const ModportSimplePortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ModportSubroutinePortSyntax : public ModportPortSyntax {
    not_null<FunctionPrototypeSyntax*> prototype;

    ModportSubroutinePortSyntax(FunctionPrototypeSyntax& prototype) :
        ModportPortSyntax(SyntaxKind::ModportSubroutinePort), prototype(&prototype) {
        this->prototype->parent = this;
    }

    explicit ModportSubroutinePortSyntax(const ModportSubroutinePortSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ModportSubroutinePortListSyntax : public MemberSyntax {
    Token importExport;
    SeparatedSyntaxList<ModportPortSyntax> ports;

    ModportSubroutinePortListSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token importExport, const SeparatedSyntaxList<ModportPortSyntax>& ports) :
        MemberSyntax(SyntaxKind::ModportSubroutinePortList, attributes), importExport(importExport), ports(ports) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    explicit ModportSubroutinePortListSyntax(const ModportSubroutinePortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ModportItemSyntax : public SyntaxNode {
    Token name;
    not_null<AnsiPortListSyntax*> ports;

    ModportItemSyntax(Token name, AnsiPortListSyntax& ports) :
        SyntaxNode(SyntaxKind::ModportItem), name(name), ports(&ports) {
        this->ports->parent = this;
    }

    explicit ModportItemSyntax(const ModportItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ModportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<ModportItemSyntax> items;
    Token semi;

    ModportDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<ModportItemSyntax>& items, Token semi) :
        MemberSyntax(SyntaxKind::ModportDeclaration, attributes), keyword(keyword), items(items), semi(semi) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit ModportDeclarationSyntax(const ModportDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClockingSkewSyntax : public SyntaxNode {
    Token edge;
    TimingControlSyntax* delay;

    ClockingSkewSyntax(Token edge, TimingControlSyntax* delay) :
        SyntaxNode(SyntaxKind::ClockingSkew), edge(edge), delay(delay) {
        if (this->delay) this->delay->parent = this;
    }

    explicit ClockingSkewSyntax(const ClockingSkewSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClockingDirectionSyntax : public SyntaxNode {
    Token input;
    ClockingSkewSyntax* inputSkew;
    Token output;
    ClockingSkewSyntax* outputSkew;

    ClockingDirectionSyntax(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* outputSkew) :
        SyntaxNode(SyntaxKind::ClockingDirection), input(input), inputSkew(inputSkew), output(output), outputSkew(outputSkew) {
        if (this->inputSkew) this->inputSkew->parent = this;
        if (this->outputSkew) this->outputSkew->parent = this;
    }

    explicit ClockingDirectionSyntax(const ClockingDirectionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DefaultSkewItemSyntax : public MemberSyntax {
    Token keyword;
    not_null<ClockingDirectionSyntax*> direction;
    Token semi;

    DefaultSkewItemSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ClockingDirectionSyntax& direction, Token semi) :
        MemberSyntax(SyntaxKind::DefaultSkewItem, attributes), keyword(keyword), direction(&direction), semi(semi) {
        this->direction->parent = this;
    }

    explicit DefaultSkewItemSyntax(const DefaultSkewItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClockingItemSyntax : public MemberSyntax {
    not_null<ClockingDirectionSyntax*> direction;
    SeparatedSyntaxList<AttributeSpecSyntax> decls;
    Token semi;

    ClockingItemSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ClockingDirectionSyntax& direction, const SeparatedSyntaxList<AttributeSpecSyntax>& decls, Token semi) :
        MemberSyntax(SyntaxKind::ClockingItem, attributes), direction(&direction), decls(decls), semi(semi) {
        this->direction->parent = this;
        this->decls.parent = this;
        for (auto child : this->decls)
            child->parent = this;
    }

    explicit ClockingItemSyntax(const ClockingItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClockingDeclarationSyntax : public MemberSyntax {
    Token globalOrDefault;
    Token clocking;
    Token blockName;
    Token at;
    not_null<EventExpressionSyntax*> event;
    Token semi;
    SyntaxList<MemberSyntax> items;
    Token endClocking;
    NamedBlockClauseSyntax* endBlockName;

    ClockingDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, EventExpressionSyntax& event, Token semi, const SyntaxList<MemberSyntax>& items, Token endClocking, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::ClockingDeclaration, attributes), globalOrDefault(globalOrDefault), clocking(clocking), blockName(blockName), at(at), event(&event), semi(semi), items(items), endClocking(endClocking), endBlockName(endBlockName) {
        this->event->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    explicit ClockingDeclarationSyntax(const ClockingDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DefaultClockingReferenceSyntax : public MemberSyntax {
    Token defaultKeyword;
    Token clocking;
    Token name;
    Token semi;

    DefaultClockingReferenceSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defaultKeyword, Token clocking, Token name, Token semi) :
        MemberSyntax(SyntaxKind::DefaultClockingReference, attributes), defaultKeyword(defaultKeyword), clocking(clocking), name(name), semi(semi) {
    }

    explicit DefaultClockingReferenceSyntax(const DefaultClockingReferenceSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DefaultDisableDeclarationSyntax : public MemberSyntax {
    Token defaultKeyword;
    Token disableKeyword;
    Token iffKeyword;
    not_null<ExpressionSyntax*> expr;
    Token semi;

    DefaultDisableDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defaultKeyword, Token disableKeyword, Token iffKeyword, ExpressionSyntax& expr, Token semi) :
        MemberSyntax(SyntaxKind::DefaultDisableDeclaration, attributes), defaultKeyword(defaultKeyword), disableKeyword(disableKeyword), iffKeyword(iffKeyword), expr(&expr), semi(semi) {
        this->expr->parent = this;
    }

    explicit DefaultDisableDeclarationSyntax(const DefaultDisableDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DPIImportSyntax : public MemberSyntax {
    Token keyword;
    Token specString;
    Token property;
    Token c_identifier;
    Token equals;
    not_null<FunctionPrototypeSyntax*> method;
    Token semi;

    DPIImportSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token specString, Token property, Token c_identifier, Token equals, FunctionPrototypeSyntax& method, Token semi) :
        MemberSyntax(SyntaxKind::DPIImport, attributes), keyword(keyword), specString(specString), property(property), c_identifier(c_identifier), equals(equals), method(&method), semi(semi) {
        this->method->parent = this;
    }

    explicit DPIImportSyntax(const DPIImportSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DPIExportSyntax : public MemberSyntax {
    Token keyword;
    Token specString;
    Token c_identifier;
    Token equals;
    Token functionOrTask;
    Token name;
    Token semi;

    DPIExportSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token specString, Token c_identifier, Token equals, Token functionOrTask, Token name, Token semi) :
        MemberSyntax(SyntaxKind::DPIExport, attributes), keyword(keyword), specString(specString), c_identifier(c_identifier), equals(equals), functionOrTask(functionOrTask), name(name), semi(semi) {
    }

    explicit DPIExportSyntax(const DPIExportSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ElabSystemTaskSyntax : public MemberSyntax {
    Token name;
    ArgumentListSyntax* arguments;
    Token semi;

    ElabSystemTaskSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token name, ArgumentListSyntax* arguments, Token semi) :
        MemberSyntax(SyntaxKind::ElabSystemTask, attributes), name(name), arguments(arguments), semi(semi) {
        if (this->arguments) this->arguments->parent = this;
    }

    explicit ElabSystemTaskSyntax(const ElabSystemTaskSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UdpPortDeclSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    UdpPortDeclSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes) :
        SyntaxNode(kind), attributes(attributes) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
    }

    explicit UdpPortDeclSyntax(const UdpPortDeclSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UdpOutputPortDeclSyntax : public UdpPortDeclSyntax {
    Token keyword;
    Token reg;
    Token name;
    EqualsValueClauseSyntax* initializer;

    UdpOutputPortDeclSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token reg, Token name, EqualsValueClauseSyntax* initializer) :
        UdpPortDeclSyntax(SyntaxKind::UdpOutputPortDecl, attributes), keyword(keyword), reg(reg), name(name), initializer(initializer) {
        if (this->initializer) this->initializer->parent = this;
    }

    explicit UdpOutputPortDeclSyntax(const UdpOutputPortDeclSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UdpInputPortDeclSyntax : public UdpPortDeclSyntax {
    Token keyword;
    SeparatedSyntaxList<IdentifierNameSyntax> names;

    UdpInputPortDeclSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& names) :
        UdpPortDeclSyntax(SyntaxKind::UdpInputPortDecl, attributes), keyword(keyword), names(names) {
        this->names.parent = this;
        for (auto child : this->names)
            child->parent = this;
    }

    explicit UdpInputPortDeclSyntax(const UdpInputPortDeclSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UdpPortListSyntax : public SyntaxNode {

    UdpPortListSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit UdpPortListSyntax(const UdpPortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT AnsiUdpPortListSyntax : public UdpPortListSyntax {
    Token openParen;
    SeparatedSyntaxList<UdpPortDeclSyntax> ports;
    Token closeParen;
    Token semi;

    AnsiUdpPortListSyntax(Token openParen, const SeparatedSyntaxList<UdpPortDeclSyntax>& ports, Token closeParen, Token semi) :
        UdpPortListSyntax(SyntaxKind::AnsiUdpPortList), openParen(openParen), ports(ports), closeParen(closeParen), semi(semi) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    explicit AnsiUdpPortListSyntax(const AnsiUdpPortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NonAnsiUdpPortListSyntax : public UdpPortListSyntax {
    Token openParen;
    SeparatedSyntaxList<IdentifierNameSyntax> ports;
    Token closeParen;
    Token semi;

    NonAnsiUdpPortListSyntax(Token openParen, const SeparatedSyntaxList<IdentifierNameSyntax>& ports, Token closeParen, Token semi) :
        UdpPortListSyntax(SyntaxKind::NonAnsiUdpPortList), openParen(openParen), ports(ports), closeParen(closeParen), semi(semi) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    explicit NonAnsiUdpPortListSyntax(const NonAnsiUdpPortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT WildcardUdpPortListSyntax : public UdpPortListSyntax {
    Token openParen;
    Token dot;
    Token star;
    Token closeParen;
    Token semi;

    WildcardUdpPortListSyntax(Token openParen, Token dot, Token star, Token closeParen, Token semi) :
        UdpPortListSyntax(SyntaxKind::WildcardUdpPortList), openParen(openParen), dot(dot), star(star), closeParen(closeParen), semi(semi) {
    }

    explicit WildcardUdpPortListSyntax(const WildcardUdpPortListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UdpInitialStmtSyntax : public SyntaxNode {
    Token initial;
    Token name;
    Token equals;
    not_null<ExpressionSyntax*> value;
    Token semi;

    UdpInitialStmtSyntax(Token initial, Token name, Token equals, ExpressionSyntax& value, Token semi) :
        SyntaxNode(SyntaxKind::UdpInitialStmt), initial(initial), name(name), equals(equals), value(&value), semi(semi) {
        this->value->parent = this;
    }

    explicit UdpInitialStmtSyntax(const UdpInitialStmtSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UdpFieldBaseSyntax : public SyntaxNode {

    UdpFieldBaseSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit UdpFieldBaseSyntax(const UdpFieldBaseSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT UdpEdgeFieldSyntax : public UdpFieldBaseSyntax {
    Token openParen;
    Token first;
    Token second;
    Token closeParen;

    UdpEdgeFieldSyntax(Token openParen, Token first, Token second, Token closeParen) :
        UdpFieldBaseSyntax(SyntaxKind::UdpEdgeField), openParen(openParen), first(first), second(second), closeParen(closeParen) {
    }

    explicit UdpEdgeFieldSyntax(const UdpEdgeFieldSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UdpSimpleFieldSyntax : public UdpFieldBaseSyntax {
    Token field;

    UdpSimpleFieldSyntax(Token field) :
        UdpFieldBaseSyntax(SyntaxKind::UdpSimpleField), field(field) {
    }

    explicit UdpSimpleFieldSyntax(const UdpSimpleFieldSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UdpEntrySyntax : public SyntaxNode {
    SyntaxList<UdpFieldBaseSyntax> inputs;
    Token colon1;
    UdpFieldBaseSyntax* current;
    Token colon2;
    UdpFieldBaseSyntax* next;
    Token semi;

    UdpEntrySyntax(const SyntaxList<UdpFieldBaseSyntax>& inputs, Token colon1, UdpFieldBaseSyntax* current, Token colon2, UdpFieldBaseSyntax* next, Token semi) :
        SyntaxNode(SyntaxKind::UdpEntry), inputs(inputs), colon1(colon1), current(current), colon2(colon2), next(next), semi(semi) {
        this->inputs.parent = this;
        for (auto child : this->inputs)
            child->parent = this;
        if (this->current) this->current->parent = this;
        if (this->next) this->next->parent = this;
    }

    explicit UdpEntrySyntax(const UdpEntrySyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UdpBodySyntax : public SyntaxNode {
    SeparatedSyntaxList<UdpPortDeclSyntax> portDecls;
    UdpInitialStmtSyntax* initialStmt;
    Token table;
    SyntaxList<UdpEntrySyntax> entries;
    Token endtable;

    UdpBodySyntax(const SeparatedSyntaxList<UdpPortDeclSyntax>& portDecls, UdpInitialStmtSyntax* initialStmt, Token table, const SyntaxList<UdpEntrySyntax>& entries, Token endtable) :
        SyntaxNode(SyntaxKind::UdpBody), portDecls(portDecls), initialStmt(initialStmt), table(table), entries(entries), endtable(endtable) {
        this->portDecls.parent = this;
        for (auto child : this->portDecls)
            child->parent = this;
        if (this->initialStmt) this->initialStmt->parent = this;
        this->entries.parent = this;
        for (auto child : this->entries)
            child->parent = this;
    }

    explicit UdpBodySyntax(const UdpBodySyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UdpDeclarationSyntax : public MemberSyntax {
    Token primitive;
    Token name;
    not_null<UdpPortListSyntax*> portList;
    not_null<UdpBodySyntax*> body;
    Token endprimitive;
    NamedBlockClauseSyntax* endBlockName;

    UdpDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token primitive, Token name, UdpPortListSyntax& portList, UdpBodySyntax& body, Token endprimitive, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::UdpDeclaration, attributes), primitive(primitive), name(name), portList(&portList), body(&body), endprimitive(endprimitive), endBlockName(endBlockName) {
        this->portList->parent = this;
        this->body->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    explicit UdpDeclarationSyntax(const UdpDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SpecparamDeclaratorSyntax : public SyntaxNode {
    Token name;
    Token equals;
    Token openParen;
    not_null<ExpressionSyntax*> value1;
    Token comma;
    ExpressionSyntax* value2;
    Token closeParen;

    SpecparamDeclaratorSyntax(Token name, Token equals, Token openParen, ExpressionSyntax& value1, Token comma, ExpressionSyntax* value2, Token closeParen) :
        SyntaxNode(SyntaxKind::SpecparamDeclarator), name(name), equals(equals), openParen(openParen), value1(&value1), comma(comma), value2(value2), closeParen(closeParen) {
        this->value1->parent = this;
        if (this->value2) this->value2->parent = this;
    }

    explicit SpecparamDeclaratorSyntax(const SpecparamDeclaratorSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SpecparamDeclarationSyntax : public MemberSyntax {
    Token keyword;
    not_null<ImplicitTypeSyntax*> type;
    SeparatedSyntaxList<SpecparamDeclaratorSyntax> declarators;
    Token semi;

    SpecparamDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ImplicitTypeSyntax& type, const SeparatedSyntaxList<SpecparamDeclaratorSyntax>& declarators, Token semi) :
        MemberSyntax(SyntaxKind::SpecparamDeclaration, attributes), keyword(keyword), type(&type), declarators(declarators), semi(semi) {
        this->type->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    explicit SpecparamDeclarationSyntax(const SpecparamDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PathSuffixSyntax : public SyntaxNode {

    PathSuffixSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit PathSuffixSyntax(const PathSuffixSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT SimplePathSuffixSyntax : public PathSuffixSyntax {
    SeparatedSyntaxList<NameSyntax> outputs;

    SimplePathSuffixSyntax(const SeparatedSyntaxList<NameSyntax>& outputs) :
        PathSuffixSyntax(SyntaxKind::SimplePathSuffix), outputs(outputs) {
        this->outputs.parent = this;
        for (auto child : this->outputs)
            child->parent = this;
    }

    explicit SimplePathSuffixSyntax(const SimplePathSuffixSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EdgeSensitivePathSuffixSyntax : public PathSuffixSyntax {
    Token openParen;
    SeparatedSyntaxList<NameSyntax> outputs;
    Token polarityOperator;
    Token colon;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;

    EdgeSensitivePathSuffixSyntax(Token openParen, const SeparatedSyntaxList<NameSyntax>& outputs, Token polarityOperator, Token colon, ExpressionSyntax& expr, Token closeParen) :
        PathSuffixSyntax(SyntaxKind::EdgeSensitivePathSuffix), openParen(openParen), outputs(outputs), polarityOperator(polarityOperator), colon(colon), expr(&expr), closeParen(closeParen) {
        this->outputs.parent = this;
        for (auto child : this->outputs)
            child->parent = this;
        this->expr->parent = this;
    }

    explicit EdgeSensitivePathSuffixSyntax(const EdgeSensitivePathSuffixSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PathDescriptionSyntax : public SyntaxNode {
    Token openParen;
    Token edgeIdentifier;
    SeparatedSyntaxList<NameSyntax> inputs;
    Token polarityOperator;
    Token pathOperator;
    not_null<PathSuffixSyntax*> suffix;
    Token closeParen;

    PathDescriptionSyntax(Token openParen, Token edgeIdentifier, const SeparatedSyntaxList<NameSyntax>& inputs, Token polarityOperator, Token pathOperator, PathSuffixSyntax& suffix, Token closeParen) :
        SyntaxNode(SyntaxKind::PathDescription), openParen(openParen), edgeIdentifier(edgeIdentifier), inputs(inputs), polarityOperator(polarityOperator), pathOperator(pathOperator), suffix(&suffix), closeParen(closeParen) {
        this->inputs.parent = this;
        for (auto child : this->inputs)
            child->parent = this;
        this->suffix->parent = this;
    }

    explicit PathDescriptionSyntax(const PathDescriptionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PathDeclarationSyntax : public MemberSyntax {
    not_null<PathDescriptionSyntax*> desc;
    Token equals;
    Token openParen;
    SeparatedSyntaxList<ExpressionSyntax> delays;
    Token closeParen;
    Token semi;

    PathDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, PathDescriptionSyntax& desc, Token equals, Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& delays, Token closeParen, Token semi) :
        MemberSyntax(SyntaxKind::PathDeclaration, attributes), desc(&desc), equals(equals), openParen(openParen), delays(delays), closeParen(closeParen), semi(semi) {
        this->desc->parent = this;
        this->delays.parent = this;
        for (auto child : this->delays)
            child->parent = this;
    }

    explicit PathDeclarationSyntax(const PathDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConditionalPathDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    not_null<ExpressionSyntax*> predicate;
    Token closeParen;
    not_null<PathDeclarationSyntax*> path;

    ConditionalPathDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& predicate, Token closeParen, PathDeclarationSyntax& path) :
        MemberSyntax(SyntaxKind::ConditionalPathDeclaration, attributes), keyword(keyword), openParen(openParen), predicate(&predicate), closeParen(closeParen), path(&path) {
        this->predicate->parent = this;
        this->path->parent = this;
    }

    explicit ConditionalPathDeclarationSyntax(const ConditionalPathDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT IfNonePathDeclarationSyntax : public MemberSyntax {
    Token keyword;
    not_null<PathDeclarationSyntax*> path;

    IfNonePathDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, PathDeclarationSyntax& path) :
        MemberSyntax(SyntaxKind::IfNonePathDeclaration, attributes), keyword(keyword), path(&path) {
        this->path->parent = this;
    }

    explicit IfNonePathDeclarationSyntax(const IfNonePathDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PulseStyleDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<NameSyntax> inputs;
    Token semi;

    PulseStyleDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<NameSyntax>& inputs, Token semi) :
        MemberSyntax(SyntaxKind::PulseStyleDeclaration, attributes), keyword(keyword), inputs(inputs), semi(semi) {
        this->inputs.parent = this;
        for (auto child : this->inputs)
            child->parent = this;
    }

    explicit PulseStyleDeclarationSyntax(const PulseStyleDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TimingCheckArgSyntax : public SyntaxNode {

    TimingCheckArgSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit TimingCheckArgSyntax(const TimingCheckArgSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT EmptyTimingCheckArgSyntax : public TimingCheckArgSyntax {
    Token placeholder;

    EmptyTimingCheckArgSyntax(Token placeholder) :
        TimingCheckArgSyntax(SyntaxKind::EmptyTimingCheckArg), placeholder(placeholder) {
    }

    explicit EmptyTimingCheckArgSyntax(const EmptyTimingCheckArgSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EdgeDescriptorSyntax : public SyntaxNode {
    Token t1;
    Token t2;

    EdgeDescriptorSyntax(Token t1, Token t2) :
        SyntaxNode(SyntaxKind::EdgeDescriptor), t1(t1), t2(t2) {
    }

    explicit EdgeDescriptorSyntax(const EdgeDescriptorSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT EdgeControlSpecifierSyntax : public SyntaxNode {
    Token openBracket;
    SeparatedSyntaxList<EdgeDescriptorSyntax> descriptors;
    Token closeBracket;

    EdgeControlSpecifierSyntax(Token openBracket, const SeparatedSyntaxList<EdgeDescriptorSyntax>& descriptors, Token closeBracket) :
        SyntaxNode(SyntaxKind::EdgeControlSpecifier), openBracket(openBracket), descriptors(descriptors), closeBracket(closeBracket) {
        this->descriptors.parent = this;
        for (auto child : this->descriptors)
            child->parent = this;
    }

    explicit EdgeControlSpecifierSyntax(const EdgeControlSpecifierSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TimingCheckEventConditionSyntax : public SyntaxNode {
    Token tripleAnd;
    not_null<ExpressionSyntax*> expr;

    TimingCheckEventConditionSyntax(Token tripleAnd, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::TimingCheckEventCondition), tripleAnd(tripleAnd), expr(&expr) {
        this->expr->parent = this;
    }

    explicit TimingCheckEventConditionSyntax(const TimingCheckEventConditionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TimingCheckEventArgSyntax : public TimingCheckArgSyntax {
    Token edge;
    EdgeControlSpecifierSyntax* controlSpecifier;
    not_null<ExpressionSyntax*> terminal;
    TimingCheckEventConditionSyntax* condition;

    TimingCheckEventArgSyntax(Token edge, EdgeControlSpecifierSyntax* controlSpecifier, ExpressionSyntax& terminal, TimingCheckEventConditionSyntax* condition) :
        TimingCheckArgSyntax(SyntaxKind::TimingCheckEventArg), edge(edge), controlSpecifier(controlSpecifier), terminal(&terminal), condition(condition) {
        if (this->controlSpecifier) this->controlSpecifier->parent = this;
        this->terminal->parent = this;
        if (this->condition) this->condition->parent = this;
    }

    explicit TimingCheckEventArgSyntax(const TimingCheckEventArgSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExpressionTimingCheckArgSyntax : public TimingCheckArgSyntax {
    not_null<ExpressionSyntax*> expr;

    ExpressionTimingCheckArgSyntax(ExpressionSyntax& expr) :
        TimingCheckArgSyntax(SyntaxKind::ExpressionTimingCheckArg), expr(&expr) {
        this->expr->parent = this;
    }

    explicit ExpressionTimingCheckArgSyntax(const ExpressionTimingCheckArgSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SystemTimingCheckSyntax : public MemberSyntax {
    Token name;
    Token openParen;
    SeparatedSyntaxList<TimingCheckArgSyntax> args;
    Token closeParen;
    Token semi;

    SystemTimingCheckSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token name, Token openParen, const SeparatedSyntaxList<TimingCheckArgSyntax>& args, Token closeParen, Token semi) :
        MemberSyntax(SyntaxKind::SystemTimingCheck, attributes), name(name), openParen(openParen), args(args), closeParen(closeParen), semi(semi) {
        this->args.parent = this;
        for (auto child : this->args)
            child->parent = this;
    }

    explicit SystemTimingCheckSyntax(const SystemTimingCheckSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SpecifyBlockSyntax : public MemberSyntax {
    Token specify;
    SyntaxList<MemberSyntax> items;
    Token endspecify;

    SpecifyBlockSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token specify, const SyntaxList<MemberSyntax>& items, Token endspecify) :
        MemberSyntax(SyntaxKind::SpecifyBlock, attributes), specify(specify), items(items), endspecify(endspecify) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit SpecifyBlockSyntax(const SpecifyBlockSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NetAliasSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<ExpressionSyntax> nets;
    Token semi;

    NetAliasSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<ExpressionSyntax>& nets, Token semi) :
        MemberSyntax(SyntaxKind::NetAlias, attributes), keyword(keyword), nets(nets), semi(semi) {
        this->nets.parent = this;
        for (auto child : this->nets)
            child->parent = this;
    }

    explicit NetAliasSyntax(const NetAliasSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExternModuleDeclSyntax : public MemberSyntax {
    Token externKeyword;
    SyntaxList<AttributeInstanceSyntax> actualAttributes;
    not_null<ModuleHeaderSyntax*> header;

    ExternModuleDeclSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token externKeyword, const SyntaxList<AttributeInstanceSyntax>& actualAttributes, ModuleHeaderSyntax& header) :
        MemberSyntax(SyntaxKind::ExternModuleDecl, attributes), externKeyword(externKeyword), actualAttributes(actualAttributes), header(&header) {
        this->actualAttributes.parent = this;
        for (auto child : this->actualAttributes)
            child->parent = this;
        this->header->parent = this;
    }

    explicit ExternModuleDeclSyntax(const ExternModuleDeclSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExternUdpDeclSyntax : public MemberSyntax {
    Token externKeyword;
    SyntaxList<AttributeInstanceSyntax> actualAttributes;
    Token primitive;
    Token name;
    not_null<UdpPortListSyntax*> portList;

    ExternUdpDeclSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token externKeyword, const SyntaxList<AttributeInstanceSyntax>& actualAttributes, Token primitive, Token name, UdpPortListSyntax& portList) :
        MemberSyntax(SyntaxKind::ExternUdpDecl, attributes), externKeyword(externKeyword), actualAttributes(actualAttributes), primitive(primitive), name(name), portList(&portList) {
        this->actualAttributes.parent = this;
        for (auto child : this->actualAttributes)
            child->parent = this;
        this->portList->parent = this;
    }

    explicit ExternUdpDeclSyntax(const ExternUdpDeclSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExternInterfaceMethodSyntax : public MemberSyntax {
    Token externKeyword;
    Token forkJoin;
    not_null<FunctionPrototypeSyntax*> prototype;
    Token semi;

    ExternInterfaceMethodSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token externKeyword, Token forkJoin, FunctionPrototypeSyntax& prototype, Token semi) :
        MemberSyntax(SyntaxKind::ExternInterfaceMethod, attributes), externKeyword(externKeyword), forkJoin(forkJoin), prototype(&prototype), semi(semi) {
        this->prototype->parent = this;
    }

    explicit ExternInterfaceMethodSyntax(const ExternInterfaceMethodSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConstraintItemSyntax : public SyntaxNode {

    ConstraintItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit ConstraintItemSyntax(const ConstraintItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT DistWeightSyntax : public SyntaxNode {
    Token op;
    Token extraOp;
    not_null<ExpressionSyntax*> expr;

    DistWeightSyntax(Token op, Token extraOp, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::DistWeight), op(op), extraOp(extraOp), expr(&expr) {
        this->expr->parent = this;
    }

    explicit DistWeightSyntax(const DistWeightSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DistItemBaseSyntax : public SyntaxNode {

    DistItemBaseSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit DistItemBaseSyntax(const DistItemBaseSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT DistItemSyntax : public DistItemBaseSyntax {
    not_null<ExpressionSyntax*> range;
    DistWeightSyntax* weight;

    DistItemSyntax(ExpressionSyntax& range, DistWeightSyntax* weight) :
        DistItemBaseSyntax(SyntaxKind::DistItem), range(&range), weight(weight) {
        this->range->parent = this;
        if (this->weight) this->weight->parent = this;
    }

    explicit DistItemSyntax(const DistItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DefaultDistItemSyntax : public DistItemBaseSyntax {
    Token defaultKeyword;
    DistWeightSyntax* weight;

    DefaultDistItemSyntax(Token defaultKeyword, DistWeightSyntax* weight) :
        DistItemBaseSyntax(SyntaxKind::DefaultDistItem), defaultKeyword(defaultKeyword), weight(weight) {
        if (this->weight) this->weight->parent = this;
    }

    explicit DefaultDistItemSyntax(const DefaultDistItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DistConstraintListSyntax : public SyntaxNode {
    Token dist;
    Token openBrace;
    SeparatedSyntaxList<DistItemBaseSyntax> items;
    Token closeBrace;

    DistConstraintListSyntax(Token dist, Token openBrace, const SeparatedSyntaxList<DistItemBaseSyntax>& items, Token closeBrace) :
        SyntaxNode(SyntaxKind::DistConstraintList), dist(dist), openBrace(openBrace), items(items), closeBrace(closeBrace) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit DistConstraintListSyntax(const DistConstraintListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExpressionOrDistSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> expr;
    not_null<DistConstraintListSyntax*> distribution;

    ExpressionOrDistSyntax(ExpressionSyntax& expr, DistConstraintListSyntax& distribution) :
        ExpressionSyntax(SyntaxKind::ExpressionOrDist), expr(&expr), distribution(&distribution) {
        this->expr->parent = this;
        this->distribution->parent = this;
    }

    explicit ExpressionOrDistSyntax(const ExpressionOrDistSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExpressionConstraintSyntax : public ConstraintItemSyntax {
    Token soft;
    not_null<ExpressionSyntax*> expr;
    Token semi;

    ExpressionConstraintSyntax(Token soft, ExpressionSyntax& expr, Token semi) :
        ConstraintItemSyntax(SyntaxKind::ExpressionConstraint), soft(soft), expr(&expr), semi(semi) {
        this->expr->parent = this;
    }

    explicit ExpressionConstraintSyntax(const ExpressionConstraintSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UniquenessConstraintSyntax : public ConstraintItemSyntax {
    Token unique;
    not_null<RangeListSyntax*> ranges;
    Token semi;

    UniquenessConstraintSyntax(Token unique, RangeListSyntax& ranges, Token semi) :
        ConstraintItemSyntax(SyntaxKind::UniquenessConstraint), unique(unique), ranges(&ranges), semi(semi) {
        this->ranges->parent = this;
    }

    explicit UniquenessConstraintSyntax(const UniquenessConstraintSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ImplicationConstraintSyntax : public ConstraintItemSyntax {
    not_null<ExpressionSyntax*> left;
    Token arrow;
    not_null<ConstraintItemSyntax*> constraints;

    ImplicationConstraintSyntax(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints) :
        ConstraintItemSyntax(SyntaxKind::ImplicationConstraint), left(&left), arrow(arrow), constraints(&constraints) {
        this->left->parent = this;
        this->constraints->parent = this;
    }

    explicit ImplicationConstraintSyntax(const ImplicationConstraintSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ElseConstraintClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    not_null<ConstraintItemSyntax*> constraints;

    ElseConstraintClauseSyntax(Token elseKeyword, ConstraintItemSyntax& constraints) :
        SyntaxNode(SyntaxKind::ElseConstraintClause), elseKeyword(elseKeyword), constraints(&constraints) {
        this->constraints->parent = this;
    }

    explicit ElseConstraintClauseSyntax(const ElseConstraintClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConditionalConstraintSyntax : public ConstraintItemSyntax {
    Token ifKeyword;
    Token openParen;
    not_null<ExpressionSyntax*> condition;
    Token closeParen;
    not_null<ConstraintItemSyntax*> constraints;
    ElseConstraintClauseSyntax* elseClause;

    ConditionalConstraintSyntax(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause) :
        ConstraintItemSyntax(SyntaxKind::ConditionalConstraint), ifKeyword(ifKeyword), openParen(openParen), condition(&condition), closeParen(closeParen), constraints(&constraints), elseClause(elseClause) {
        this->condition->parent = this;
        this->constraints->parent = this;
        if (this->elseClause) this->elseClause->parent = this;
    }

    explicit ConditionalConstraintSyntax(const ConditionalConstraintSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT LoopConstraintSyntax : public ConstraintItemSyntax {
    Token foreachKeyword;
    not_null<ForeachLoopListSyntax*> loopList;
    not_null<ConstraintItemSyntax*> constraints;

    LoopConstraintSyntax(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints) :
        ConstraintItemSyntax(SyntaxKind::LoopConstraint), foreachKeyword(foreachKeyword), loopList(&loopList), constraints(&constraints) {
        this->loopList->parent = this;
        this->constraints->parent = this;
    }

    explicit LoopConstraintSyntax(const LoopConstraintSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DisableConstraintSyntax : public ConstraintItemSyntax {
    Token disable;
    Token soft;
    not_null<ExpressionSyntax*> name;
    Token semi;

    DisableConstraintSyntax(Token disable, Token soft, ExpressionSyntax& name, Token semi) :
        ConstraintItemSyntax(SyntaxKind::DisableConstraint), disable(disable), soft(soft), name(&name), semi(semi) {
        this->name->parent = this;
    }

    explicit DisableConstraintSyntax(const DisableConstraintSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SolveBeforeConstraintSyntax : public ConstraintItemSyntax {
    Token solve;
    SeparatedSyntaxList<ExpressionSyntax> beforeExpr;
    Token before;
    SeparatedSyntaxList<ExpressionSyntax> afterExpr;
    Token semi;

    SolveBeforeConstraintSyntax(Token solve, const SeparatedSyntaxList<ExpressionSyntax>& beforeExpr, Token before, const SeparatedSyntaxList<ExpressionSyntax>& afterExpr, Token semi) :
        ConstraintItemSyntax(SyntaxKind::SolveBeforeConstraint), solve(solve), beforeExpr(beforeExpr), before(before), afterExpr(afterExpr), semi(semi) {
        this->beforeExpr.parent = this;
        for (auto child : this->beforeExpr)
            child->parent = this;
        this->afterExpr.parent = this;
        for (auto child : this->afterExpr)
            child->parent = this;
    }

    explicit SolveBeforeConstraintSyntax(const SolveBeforeConstraintSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConstraintBlockSyntax : public ConstraintItemSyntax {
    Token openBrace;
    SyntaxList<ConstraintItemSyntax> items;
    Token closeBrace;

    ConstraintBlockSyntax(Token openBrace, const SyntaxList<ConstraintItemSyntax>& items, Token closeBrace) :
        ConstraintItemSyntax(SyntaxKind::ConstraintBlock), openBrace(openBrace), items(items), closeBrace(closeBrace) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit ConstraintBlockSyntax(const ConstraintBlockSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConstraintPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    SyntaxList<ClassSpecifierSyntax> specifiers;
    not_null<NameSyntax*> name;
    Token semi;

    ConstraintPrototypeSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, const SyntaxList<ClassSpecifierSyntax>& specifiers, NameSyntax& name, Token semi) :
        MemberSyntax(SyntaxKind::ConstraintPrototype, attributes), qualifiers(qualifiers), keyword(keyword), specifiers(specifiers), name(&name), semi(semi) {
        this->qualifiers.parent = this;
        this->specifiers.parent = this;
        for (auto child : this->specifiers)
            child->parent = this;
        this->name->parent = this;
    }

    explicit ConstraintPrototypeSyntax(const ConstraintPrototypeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConstraintDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    SyntaxList<ClassSpecifierSyntax> specifiers;
    not_null<NameSyntax*> name;
    not_null<ConstraintBlockSyntax*> block;

    ConstraintDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, const SyntaxList<ClassSpecifierSyntax>& specifiers, NameSyntax& name, ConstraintBlockSyntax& block) :
        MemberSyntax(SyntaxKind::ConstraintDeclaration, attributes), qualifiers(qualifiers), keyword(keyword), specifiers(specifiers), name(&name), block(&block) {
        this->qualifiers.parent = this;
        this->specifiers.parent = this;
        for (auto child : this->specifiers)
            child->parent = this;
        this->name->parent = this;
        this->block->parent = this;
    }

    explicit ConstraintDeclarationSyntax(const ConstraintDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParenExpressionListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token closeParen;

    ParenExpressionListSyntax(Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeParen) :
        SyntaxNode(SyntaxKind::ParenExpressionList), openParen(openParen), expressions(expressions), closeParen(closeParen) {
        this->expressions.parent = this;
        for (auto child : this->expressions)
            child->parent = this;
    }

    explicit ParenExpressionListSyntax(const ParenExpressionListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ArrayOrRandomizeMethodExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> method;
    Token with;
    ParenExpressionListSyntax* args;
    ConstraintBlockSyntax* constraints;

    ArrayOrRandomizeMethodExpressionSyntax(ExpressionSyntax& method, Token with, ParenExpressionListSyntax* args, ConstraintBlockSyntax* constraints) :
        ExpressionSyntax(SyntaxKind::ArrayOrRandomizeMethodExpression), method(&method), with(with), args(args), constraints(constraints) {
        this->method->parent = this;
        if (this->args) this->args->parent = this;
        if (this->constraints) this->constraints->parent = this;
    }

    explicit ArrayOrRandomizeMethodExpressionSyntax(const ArrayOrRandomizeMethodExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT WithFunctionSampleSyntax : public SyntaxNode {
    Token with;
    Token function;
    Token sample;
    FunctionPortListSyntax* portList;

    WithFunctionSampleSyntax(Token with, Token function, Token sample, FunctionPortListSyntax* portList) :
        SyntaxNode(SyntaxKind::WithFunctionSample), with(with), function(function), sample(sample), portList(portList) {
        if (this->portList) this->portList->parent = this;
    }

    explicit WithFunctionSampleSyntax(const WithFunctionSampleSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BlockEventExpressionSyntax : public SyntaxNode {

    BlockEventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit BlockEventExpressionSyntax(const BlockEventExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT BinaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    not_null<BlockEventExpressionSyntax*> left;
    Token orKeyword;
    not_null<BlockEventExpressionSyntax*> right;

    BinaryBlockEventExpressionSyntax(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right) :
        BlockEventExpressionSyntax(SyntaxKind::BinaryBlockEventExpression), left(&left), orKeyword(orKeyword), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    explicit BinaryBlockEventExpressionSyntax(const BinaryBlockEventExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PrimaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    Token keyword;
    not_null<NameSyntax*> name;

    PrimaryBlockEventExpressionSyntax(Token keyword, NameSyntax& name) :
        BlockEventExpressionSyntax(SyntaxKind::PrimaryBlockEventExpression), keyword(keyword), name(&name) {
        this->name->parent = this;
    }

    explicit PrimaryBlockEventExpressionSyntax(const PrimaryBlockEventExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BlockCoverageEventSyntax : public SyntaxNode {
    Token atat;
    Token openParen;
    not_null<BlockEventExpressionSyntax*> expr;
    Token closeParen;

    BlockCoverageEventSyntax(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::BlockCoverageEvent), atat(atat), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    explicit BlockCoverageEventSyntax(const BlockCoverageEventSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CovergroupDeclarationSyntax : public MemberSyntax {
    Token covergroup;
    Token extends;
    Token name;
    FunctionPortListSyntax* portList;
    SyntaxNode* event;
    Token semi;
    SyntaxList<MemberSyntax> members;
    Token endgroup;
    NamedBlockClauseSyntax* endBlockName;

    CovergroupDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token covergroup, Token extends, Token name, FunctionPortListSyntax* portList, SyntaxNode* event, Token semi, const SyntaxList<MemberSyntax>& members, Token endgroup, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::CovergroupDeclaration, attributes), covergroup(covergroup), extends(extends), name(name), portList(portList), event(event), semi(semi), members(members), endgroup(endgroup), endBlockName(endBlockName) {
        if (this->portList) this->portList->parent = this;
        if (this->event) this->event->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    explicit CovergroupDeclarationSyntax(const CovergroupDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CoverageOptionSyntax : public MemberSyntax {
    not_null<ExpressionSyntax*> expr;
    Token semi;

    CoverageOptionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr, Token semi) :
        MemberSyntax(SyntaxKind::CoverageOption, attributes), expr(&expr), semi(semi) {
        this->expr->parent = this;
    }

    explicit CoverageOptionSyntax(const CoverageOptionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CoverageIffClauseSyntax : public SyntaxNode {
    Token iff;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;

    CoverageIffClauseSyntax(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::CoverageIffClause), iff(iff), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    explicit CoverageIffClauseSyntax(const CoverageIffClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CoverpointSyntax : public MemberSyntax {
    not_null<DataTypeSyntax*> type;
    NamedLabelSyntax* label;
    Token coverpoint;
    not_null<ExpressionSyntax*> expr;
    CoverageIffClauseSyntax* iff;
    Token openBrace;
    SyntaxList<MemberSyntax> members;
    Token closeBrace;
    Token emptySemi;

    CoverpointSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, DataTypeSyntax& type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, CoverageIffClauseSyntax* iff, Token openBrace, const SyntaxList<MemberSyntax>& members, Token closeBrace, Token emptySemi) :
        MemberSyntax(SyntaxKind::Coverpoint, attributes), type(&type), label(label), coverpoint(coverpoint), expr(&expr), iff(iff), openBrace(openBrace), members(members), closeBrace(closeBrace), emptySemi(emptySemi) {
        this->type->parent = this;
        if (this->label) this->label->parent = this;
        this->expr->parent = this;
        if (this->iff) this->iff->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
    }

    explicit CoverpointSyntax(const CoverpointSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CoverageBinInitializerSyntax : public SyntaxNode {

    CoverageBinInitializerSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit CoverageBinInitializerSyntax(const CoverageBinInitializerSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT DefaultCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    Token defaultKeyword;
    Token sequenceKeyword;

    DefaultCoverageBinInitializerSyntax(Token defaultKeyword, Token sequenceKeyword) :
        CoverageBinInitializerSyntax(SyntaxKind::DefaultCoverageBinInitializer), defaultKeyword(defaultKeyword), sequenceKeyword(sequenceKeyword) {
    }

    explicit DefaultCoverageBinInitializerSyntax(const DefaultCoverageBinInitializerSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT WithClauseSyntax : public SyntaxNode {
    Token with;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;

    WithClauseSyntax(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::WithClause), with(with), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    explicit WithClauseSyntax(const WithClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ExpressionCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    not_null<ExpressionSyntax*> expr;

    ExpressionCoverageBinInitializerSyntax(ExpressionSyntax& expr) :
        CoverageBinInitializerSyntax(SyntaxKind::ExpressionCoverageBinInitializer), expr(&expr) {
        this->expr->parent = this;
    }

    explicit ExpressionCoverageBinInitializerSyntax(const ExpressionCoverageBinInitializerSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT RangeCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    not_null<RangeListSyntax*> ranges;
    WithClauseSyntax* withClause;

    RangeCoverageBinInitializerSyntax(RangeListSyntax& ranges, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::RangeCoverageBinInitializer), ranges(&ranges), withClause(withClause) {
        this->ranges->parent = this;
        if (this->withClause) this->withClause->parent = this;
    }

    explicit RangeCoverageBinInitializerSyntax(const RangeCoverageBinInitializerSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT IdWithExprCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    Token id;
    not_null<WithClauseSyntax*> withClause;

    IdWithExprCoverageBinInitializerSyntax(Token id, WithClauseSyntax& withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::IdWithExprCoverageBinInitializer), id(id), withClause(&withClause) {
        this->withClause->parent = this;
    }

    explicit IdWithExprCoverageBinInitializerSyntax(const IdWithExprCoverageBinInitializerSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TransRepeatRangeSyntax : public SyntaxNode {
    Token openBracket;
    Token specifier;
    SelectorSyntax* selector;
    Token closeBracket;

    TransRepeatRangeSyntax(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket) :
        SyntaxNode(SyntaxKind::TransRepeatRange), openBracket(openBracket), specifier(specifier), selector(selector), closeBracket(closeBracket) {
        if (this->selector) this->selector->parent = this;
    }

    explicit TransRepeatRangeSyntax(const TransRepeatRangeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TransRangeSyntax : public SyntaxNode {
    SeparatedSyntaxList<ExpressionSyntax> items;
    TransRepeatRangeSyntax* repeat;

    TransRangeSyntax(const SeparatedSyntaxList<ExpressionSyntax>& items, TransRepeatRangeSyntax* repeat) :
        SyntaxNode(SyntaxKind::TransRange), items(items), repeat(repeat) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
        if (this->repeat) this->repeat->parent = this;
    }

    explicit TransRangeSyntax(const TransRangeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TransSetSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<TransRangeSyntax> ranges;
    Token closeParen;

    TransSetSyntax(Token openParen, const SeparatedSyntaxList<TransRangeSyntax>& ranges, Token closeParen) :
        SyntaxNode(SyntaxKind::TransSet), openParen(openParen), ranges(ranges), closeParen(closeParen) {
        this->ranges.parent = this;
        for (auto child : this->ranges)
            child->parent = this;
    }

    explicit TransSetSyntax(const TransSetSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TransListCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    SeparatedSyntaxList<TransSetSyntax> sets;

    TransListCoverageBinInitializerSyntax(const SeparatedSyntaxList<TransSetSyntax>& sets) :
        CoverageBinInitializerSyntax(SyntaxKind::TransListCoverageBinInitializer), sets(sets) {
        this->sets.parent = this;
        for (auto child : this->sets)
            child->parent = this;
    }

    explicit TransListCoverageBinInitializerSyntax(const TransListCoverageBinInitializerSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CoverageBinsArraySizeSyntax : public SyntaxNode {
    Token openBracket;
    ExpressionSyntax* expr;
    Token closeBracket;

    CoverageBinsArraySizeSyntax(Token openBracket, ExpressionSyntax* expr, Token closeBracket) :
        SyntaxNode(SyntaxKind::CoverageBinsArraySize), openBracket(openBracket), expr(expr), closeBracket(closeBracket) {
        if (this->expr) this->expr->parent = this;
    }

    explicit CoverageBinsArraySizeSyntax(const CoverageBinsArraySizeSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CoverageBinsSyntax : public MemberSyntax {
    Token wildcard;
    Token keyword;
    Token name;
    CoverageBinsArraySizeSyntax* size;
    Token equals;
    not_null<CoverageBinInitializerSyntax*> initializer;
    CoverageIffClauseSyntax* iff;
    Token semi;

    CoverageBinsSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token wildcard, Token keyword, Token name, CoverageBinsArraySizeSyntax* size, Token equals, CoverageBinInitializerSyntax& initializer, CoverageIffClauseSyntax* iff, Token semi) :
        MemberSyntax(SyntaxKind::CoverageBins, attributes), wildcard(wildcard), keyword(keyword), name(name), size(size), equals(equals), initializer(&initializer), iff(iff), semi(semi) {
        if (this->size) this->size->parent = this;
        this->initializer->parent = this;
        if (this->iff) this->iff->parent = this;
    }

    explicit CoverageBinsSyntax(const CoverageBinsSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CoverCrossSyntax : public MemberSyntax {
    NamedLabelSyntax* label;
    Token cross;
    SeparatedSyntaxList<IdentifierNameSyntax> items;
    CoverageIffClauseSyntax* iff;
    Token openBrace;
    SyntaxList<MemberSyntax> members;
    Token closeBrace;
    Token emptySemi;

    CoverCrossSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, NamedLabelSyntax* label, Token cross, const SeparatedSyntaxList<IdentifierNameSyntax>& items, CoverageIffClauseSyntax* iff, Token openBrace, const SyntaxList<MemberSyntax>& members, Token closeBrace, Token emptySemi) :
        MemberSyntax(SyntaxKind::CoverCross, attributes), label(label), cross(cross), items(items), iff(iff), openBrace(openBrace), members(members), closeBrace(closeBrace), emptySemi(emptySemi) {
        if (this->label) this->label->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
        if (this->iff) this->iff->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
    }

    explicit CoverCrossSyntax(const CoverCrossSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BinsSelectExpressionSyntax : public SyntaxNode {

    BinsSelectExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit BinsSelectExpressionSyntax(const BinsSelectExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT IntersectClauseSyntax : public SyntaxNode {
    Token intersect;
    not_null<RangeListSyntax*> ranges;

    IntersectClauseSyntax(Token intersect, RangeListSyntax& ranges) :
        SyntaxNode(SyntaxKind::IntersectClause), intersect(intersect), ranges(&ranges) {
        this->ranges->parent = this;
    }

    explicit IntersectClauseSyntax(const IntersectClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BinsSelectConditionExprSyntax : public BinsSelectExpressionSyntax {
    Token binsof;
    Token openParen;
    not_null<NameSyntax*> name;
    Token closeParen;
    IntersectClauseSyntax* intersects;

    BinsSelectConditionExprSyntax(Token binsof, Token openParen, NameSyntax& name, Token closeParen, IntersectClauseSyntax* intersects) :
        BinsSelectExpressionSyntax(SyntaxKind::BinsSelectConditionExpr), binsof(binsof), openParen(openParen), name(&name), closeParen(closeParen), intersects(intersects) {
        this->name->parent = this;
        if (this->intersects) this->intersects->parent = this;
    }

    explicit BinsSelectConditionExprSyntax(const BinsSelectConditionExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UnaryBinsSelectExprSyntax : public BinsSelectExpressionSyntax {
    Token op;
    not_null<BinsSelectConditionExprSyntax*> expr;

    UnaryBinsSelectExprSyntax(Token op, BinsSelectConditionExprSyntax& expr) :
        BinsSelectExpressionSyntax(SyntaxKind::UnaryBinsSelectExpr), op(op), expr(&expr) {
        this->expr->parent = this;
    }

    explicit UnaryBinsSelectExprSyntax(const UnaryBinsSelectExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BinaryBinsSelectExprSyntax : public BinsSelectExpressionSyntax {
    not_null<BinsSelectExpressionSyntax*> left;
    Token op;
    not_null<BinsSelectExpressionSyntax*> right;

    BinaryBinsSelectExprSyntax(BinsSelectExpressionSyntax& left, Token op, BinsSelectExpressionSyntax& right) :
        BinsSelectExpressionSyntax(SyntaxKind::BinaryBinsSelectExpr), left(&left), op(op), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    explicit BinaryBinsSelectExprSyntax(const BinaryBinsSelectExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParenthesizedBinsSelectExprSyntax : public BinsSelectExpressionSyntax {
    Token openParen;
    not_null<BinsSelectExpressionSyntax*> expr;
    Token closeParen;

    ParenthesizedBinsSelectExprSyntax(Token openParen, BinsSelectExpressionSyntax& expr, Token closeParen) :
        BinsSelectExpressionSyntax(SyntaxKind::ParenthesizedBinsSelectExpr), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    explicit ParenthesizedBinsSelectExprSyntax(const ParenthesizedBinsSelectExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SimpleBinsSelectExprSyntax : public BinsSelectExpressionSyntax {
    not_null<ExpressionSyntax*> expr;
    MatchesClauseSyntax* matchesClause;

    SimpleBinsSelectExprSyntax(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause) :
        BinsSelectExpressionSyntax(SyntaxKind::SimpleBinsSelectExpr), expr(&expr), matchesClause(matchesClause) {
        this->expr->parent = this;
        if (this->matchesClause) this->matchesClause->parent = this;
    }

    explicit SimpleBinsSelectExprSyntax(const SimpleBinsSelectExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BinSelectWithFilterExprSyntax : public BinsSelectExpressionSyntax {
    not_null<BinsSelectExpressionSyntax*> expr;
    Token with;
    Token openParen;
    not_null<ExpressionSyntax*> filter;
    Token closeParen;
    MatchesClauseSyntax* matchesClause;

    BinSelectWithFilterExprSyntax(BinsSelectExpressionSyntax& expr, Token with, Token openParen, ExpressionSyntax& filter, Token closeParen, MatchesClauseSyntax* matchesClause) :
        BinsSelectExpressionSyntax(SyntaxKind::BinSelectWithFilterExpr), expr(&expr), with(with), openParen(openParen), filter(&filter), closeParen(closeParen), matchesClause(matchesClause) {
        this->expr->parent = this;
        this->filter->parent = this;
        if (this->matchesClause) this->matchesClause->parent = this;
    }

    explicit BinSelectWithFilterExprSyntax(const BinSelectWithFilterExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BinsSelectionSyntax : public MemberSyntax {
    Token keyword;
    Token name;
    Token equals;
    not_null<BinsSelectExpressionSyntax*> expr;
    CoverageIffClauseSyntax* iff;
    Token semi;

    BinsSelectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, Token equals, BinsSelectExpressionSyntax& expr, CoverageIffClauseSyntax* iff, Token semi) :
        MemberSyntax(SyntaxKind::BinsSelection, attributes), keyword(keyword), name(name), equals(equals), expr(&expr), iff(iff), semi(semi) {
        this->expr->parent = this;
        if (this->iff) this->iff->parent = this;
    }

    explicit BinsSelectionSyntax(const BinsSelectionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SequenceRepetitionSyntax : public SyntaxNode {
    Token openBracket;
    Token op;
    SelectorSyntax* selector;
    Token closeBracket;

    SequenceRepetitionSyntax(Token openBracket, Token op, SelectorSyntax* selector, Token closeBracket) :
        SyntaxNode(SyntaxKind::SequenceRepetition), openBracket(openBracket), op(op), selector(selector), closeBracket(closeBracket) {
        if (this->selector) this->selector->parent = this;
    }

    explicit SequenceRepetitionSyntax(const SequenceRepetitionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SimpleSequenceExprSyntax : public SequenceExprSyntax {
    not_null<ExpressionSyntax*> expr;
    SequenceRepetitionSyntax* repetition;

    SimpleSequenceExprSyntax(ExpressionSyntax& expr, SequenceRepetitionSyntax* repetition) :
        SequenceExprSyntax(SyntaxKind::SimpleSequenceExpr), expr(&expr), repetition(repetition) {
        this->expr->parent = this;
        if (this->repetition) this->repetition->parent = this;
    }

    explicit SimpleSequenceExprSyntax(const SimpleSequenceExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SequenceMatchListSyntax : public SyntaxNode {
    Token comma;
    SeparatedSyntaxList<PropertyExprSyntax> items;

    SequenceMatchListSyntax(Token comma, const SeparatedSyntaxList<PropertyExprSyntax>& items) :
        SyntaxNode(SyntaxKind::SequenceMatchList), comma(comma), items(items) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit SequenceMatchListSyntax(const SequenceMatchListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParenthesizedSequenceExprSyntax : public SequenceExprSyntax {
    Token openParen;
    not_null<SequenceExprSyntax*> expr;
    SequenceMatchListSyntax* matchList;
    Token closeParen;
    SequenceRepetitionSyntax* repetition;

    ParenthesizedSequenceExprSyntax(Token openParen, SequenceExprSyntax& expr, SequenceMatchListSyntax* matchList, Token closeParen, SequenceRepetitionSyntax* repetition) :
        SequenceExprSyntax(SyntaxKind::ParenthesizedSequenceExpr), openParen(openParen), expr(&expr), matchList(matchList), closeParen(closeParen), repetition(repetition) {
        this->expr->parent = this;
        if (this->matchList) this->matchList->parent = this;
        if (this->repetition) this->repetition->parent = this;
    }

    explicit ParenthesizedSequenceExprSyntax(const ParenthesizedSequenceExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BinarySequenceExprSyntax : public SequenceExprSyntax {
    not_null<SequenceExprSyntax*> left;
    Token op;
    not_null<SequenceExprSyntax*> right;

    BinarySequenceExprSyntax(SyntaxKind kind, SequenceExprSyntax& left, Token op, SequenceExprSyntax& right) :
        SequenceExprSyntax(kind), left(&left), op(op), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    explicit BinarySequenceExprSyntax(const BinarySequenceExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT FirstMatchSequenceExprSyntax : public SequenceExprSyntax {
    Token first_match;
    Token openParen;
    not_null<SequenceExprSyntax*> expr;
    SequenceMatchListSyntax* matchList;
    Token closeParen;

    FirstMatchSequenceExprSyntax(Token first_match, Token openParen, SequenceExprSyntax& expr, SequenceMatchListSyntax* matchList, Token closeParen) :
        SequenceExprSyntax(SyntaxKind::FirstMatchSequenceExpr), first_match(first_match), openParen(openParen), expr(&expr), matchList(matchList), closeParen(closeParen) {
        this->expr->parent = this;
        if (this->matchList) this->matchList->parent = this;
    }

    explicit FirstMatchSequenceExprSyntax(const FirstMatchSequenceExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClockingSequenceExprSyntax : public SequenceExprSyntax {
    not_null<TimingControlSyntax*> event;
    not_null<SequenceExprSyntax*> expr;

    ClockingSequenceExprSyntax(TimingControlSyntax& event, SequenceExprSyntax& expr) :
        SequenceExprSyntax(SyntaxKind::ClockingSequenceExpr), event(&event), expr(&expr) {
        this->event->parent = this;
        this->expr->parent = this;
    }

    explicit ClockingSequenceExprSyntax(const ClockingSequenceExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DelayedSequenceElementSyntax : public SyntaxNode {
    Token doubleHash;
    ExpressionSyntax* delayVal;
    Token openBracket;
    Token op;
    SelectorSyntax* range;
    Token closeBracket;
    not_null<SequenceExprSyntax*> expr;

    DelayedSequenceElementSyntax(Token doubleHash, ExpressionSyntax* delayVal, Token openBracket, Token op, SelectorSyntax* range, Token closeBracket, SequenceExprSyntax& expr) :
        SyntaxNode(SyntaxKind::DelayedSequenceElement), doubleHash(doubleHash), delayVal(delayVal), openBracket(openBracket), op(op), range(range), closeBracket(closeBracket), expr(&expr) {
        if (this->delayVal) this->delayVal->parent = this;
        if (this->range) this->range->parent = this;
        this->expr->parent = this;
    }

    explicit DelayedSequenceElementSyntax(const DelayedSequenceElementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DelayedSequenceExprSyntax : public SequenceExprSyntax {
    SequenceExprSyntax* first;
    SyntaxList<DelayedSequenceElementSyntax> elements;

    DelayedSequenceExprSyntax(SequenceExprSyntax* first, const SyntaxList<DelayedSequenceElementSyntax>& elements) :
        SequenceExprSyntax(SyntaxKind::DelayedSequenceExpr), first(first), elements(elements) {
        if (this->first) this->first->parent = this;
        this->elements.parent = this;
        for (auto child : this->elements)
            child->parent = this;
    }

    explicit DelayedSequenceExprSyntax(const DelayedSequenceExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SimplePropertyExprSyntax : public PropertyExprSyntax {
    not_null<SequenceExprSyntax*> expr;

    SimplePropertyExprSyntax(SequenceExprSyntax& expr) :
        PropertyExprSyntax(SyntaxKind::SimplePropertyExpr), expr(&expr) {
        this->expr->parent = this;
    }

    explicit SimplePropertyExprSyntax(const SimplePropertyExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParenthesizedPropertyExprSyntax : public PropertyExprSyntax {
    Token openParen;
    not_null<PropertyExprSyntax*> expr;
    SequenceMatchListSyntax* matchList;
    Token closeParen;

    ParenthesizedPropertyExprSyntax(Token openParen, PropertyExprSyntax& expr, SequenceMatchListSyntax* matchList, Token closeParen) :
        PropertyExprSyntax(SyntaxKind::ParenthesizedPropertyExpr), openParen(openParen), expr(&expr), matchList(matchList), closeParen(closeParen) {
        this->expr->parent = this;
        if (this->matchList) this->matchList->parent = this;
    }

    explicit ParenthesizedPropertyExprSyntax(const ParenthesizedPropertyExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StrongWeakPropertyExprSyntax : public PropertyExprSyntax {
    Token keyword;
    Token openParen;
    not_null<SequenceExprSyntax*> expr;
    Token closeParen;

    StrongWeakPropertyExprSyntax(Token keyword, Token openParen, SequenceExprSyntax& expr, Token closeParen) :
        PropertyExprSyntax(SyntaxKind::StrongWeakPropertyExpr), keyword(keyword), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    explicit StrongWeakPropertyExprSyntax(const StrongWeakPropertyExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UnaryPropertyExprSyntax : public PropertyExprSyntax {
    Token op;
    not_null<PropertyExprSyntax*> expr;

    UnaryPropertyExprSyntax(Token op, PropertyExprSyntax& expr) :
        PropertyExprSyntax(SyntaxKind::UnaryPropertyExpr), op(op), expr(&expr) {
        this->expr->parent = this;
    }

    explicit UnaryPropertyExprSyntax(const UnaryPropertyExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UnarySelectPropertyExprSyntax : public PropertyExprSyntax {
    Token op;
    Token openBracket;
    SelectorSyntax* selector;
    Token closeBracket;
    not_null<PropertyExprSyntax*> expr;

    UnarySelectPropertyExprSyntax(Token op, Token openBracket, SelectorSyntax* selector, Token closeBracket, PropertyExprSyntax& expr) :
        PropertyExprSyntax(SyntaxKind::UnarySelectPropertyExpr), op(op), openBracket(openBracket), selector(selector), closeBracket(closeBracket), expr(&expr) {
        if (this->selector) this->selector->parent = this;
        this->expr->parent = this;
    }

    explicit UnarySelectPropertyExprSyntax(const UnarySelectPropertyExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BinaryPropertyExprSyntax : public PropertyExprSyntax {
    not_null<PropertyExprSyntax*> left;
    Token op;
    not_null<PropertyExprSyntax*> right;

    BinaryPropertyExprSyntax(SyntaxKind kind, PropertyExprSyntax& left, Token op, PropertyExprSyntax& right) :
        PropertyExprSyntax(kind), left(&left), op(op), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    explicit BinaryPropertyExprSyntax(const BinaryPropertyExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ClockingPropertyExprSyntax : public PropertyExprSyntax {
    not_null<TimingControlSyntax*> event;
    PropertyExprSyntax* expr;

    ClockingPropertyExprSyntax(TimingControlSyntax& event, PropertyExprSyntax* expr) :
        PropertyExprSyntax(SyntaxKind::ClockingPropertyExpr), event(&event), expr(expr) {
        this->event->parent = this;
        if (this->expr) this->expr->parent = this;
    }

    explicit ClockingPropertyExprSyntax(const ClockingPropertyExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT AcceptOnPropertyExprSyntax : public PropertyExprSyntax {
    Token keyword;
    Token openParen;
    not_null<ExpressionSyntax*> condition;
    Token closeParen;
    not_null<PropertyExprSyntax*> expr;

    AcceptOnPropertyExprSyntax(Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, PropertyExprSyntax& expr) :
        PropertyExprSyntax(SyntaxKind::AcceptOnPropertyExpr), keyword(keyword), openParen(openParen), condition(&condition), closeParen(closeParen), expr(&expr) {
        this->condition->parent = this;
        this->expr->parent = this;
    }

    explicit AcceptOnPropertyExprSyntax(const AcceptOnPropertyExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ElsePropertyClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    not_null<PropertyExprSyntax*> expr;

    ElsePropertyClauseSyntax(Token elseKeyword, PropertyExprSyntax& expr) :
        SyntaxNode(SyntaxKind::ElsePropertyClause), elseKeyword(elseKeyword), expr(&expr) {
        this->expr->parent = this;
    }

    explicit ElsePropertyClauseSyntax(const ElsePropertyClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConditionalPropertyExprSyntax : public PropertyExprSyntax {
    Token ifKeyword;
    Token openParen;
    not_null<ExpressionSyntax*> condition;
    Token closeParen;
    not_null<PropertyExprSyntax*> expr;
    ElsePropertyClauseSyntax* elseClause;

    ConditionalPropertyExprSyntax(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, PropertyExprSyntax& expr, ElsePropertyClauseSyntax* elseClause) :
        PropertyExprSyntax(SyntaxKind::ConditionalPropertyExpr), ifKeyword(ifKeyword), openParen(openParen), condition(&condition), closeParen(closeParen), expr(&expr), elseClause(elseClause) {
        this->condition->parent = this;
        this->expr->parent = this;
        if (this->elseClause) this->elseClause->parent = this;
    }

    explicit ConditionalPropertyExprSyntax(const ConditionalPropertyExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PropertyCaseItemSyntax : public SyntaxNode {

    PropertyCaseItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit PropertyCaseItemSyntax(const PropertyCaseItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT DefaultPropertyCaseItemSyntax : public PropertyCaseItemSyntax {
    Token defaultKeyword;
    Token colon;
    not_null<PropertyExprSyntax*> expr;
    Token semi;

    DefaultPropertyCaseItemSyntax(Token defaultKeyword, Token colon, PropertyExprSyntax& expr, Token semi) :
        PropertyCaseItemSyntax(SyntaxKind::DefaultPropertyCaseItem), defaultKeyword(defaultKeyword), colon(colon), expr(&expr), semi(semi) {
        this->expr->parent = this;
    }

    explicit DefaultPropertyCaseItemSyntax(const DefaultPropertyCaseItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT StandardPropertyCaseItemSyntax : public PropertyCaseItemSyntax {
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token colon;
    not_null<PropertyExprSyntax*> expr;
    Token semi;

    StandardPropertyCaseItemSyntax(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, PropertyExprSyntax& expr, Token semi) :
        PropertyCaseItemSyntax(SyntaxKind::StandardPropertyCaseItem), expressions(expressions), colon(colon), expr(&expr), semi(semi) {
        this->expressions.parent = this;
        for (auto child : this->expressions)
            child->parent = this;
        this->expr->parent = this;
    }

    explicit StandardPropertyCaseItemSyntax(const StandardPropertyCaseItemSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CasePropertyExprSyntax : public PropertyExprSyntax {
    Token caseKeyword;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    SyntaxList<PropertyCaseItemSyntax> items;
    Token endcase;

    CasePropertyExprSyntax(Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, const SyntaxList<PropertyCaseItemSyntax>& items, Token endcase) :
        PropertyExprSyntax(SyntaxKind::CasePropertyExpr), caseKeyword(caseKeyword), openParen(openParen), expr(&expr), closeParen(closeParen), items(items), endcase(endcase) {
        this->expr->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    explicit CasePropertyExprSyntax(const CasePropertyExprSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT LocalVariableDeclarationSyntax : public MemberSyntax {
    Token var;
    not_null<DataTypeSyntax*> type;
    SeparatedSyntaxList<DeclaratorSyntax> declarators;
    Token semi;

    LocalVariableDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token var, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
        MemberSyntax(SyntaxKind::LocalVariableDeclaration, attributes), var(var), type(&type), declarators(declarators), semi(semi) {
        this->type->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    explicit LocalVariableDeclarationSyntax(const LocalVariableDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PropertyDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token name;
    AssertionItemPortListSyntax* portList;
    Token semi;
    SyntaxList<LocalVariableDeclarationSyntax> variables;
    not_null<PropertySpecSyntax*> propertySpec;
    Token optionalSemi;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    PropertyDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<LocalVariableDeclarationSyntax>& variables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::PropertyDeclaration, attributes), keyword(keyword), name(name), portList(portList), semi(semi), variables(variables), propertySpec(&propertySpec), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName) {
        if (this->portList) this->portList->parent = this;
        this->variables.parent = this;
        for (auto child : this->variables)
            child->parent = this;
        this->propertySpec->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    explicit PropertyDeclarationSyntax(const PropertyDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SequenceDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token name;
    AssertionItemPortListSyntax* portList;
    Token semi;
    SyntaxList<LocalVariableDeclarationSyntax> variables;
    not_null<SequenceExprSyntax*> seqExpr;
    Token optionalSemi;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    SequenceDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<LocalVariableDeclarationSyntax>& variables, SequenceExprSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::SequenceDeclaration, attributes), keyword(keyword), name(name), portList(portList), semi(semi), variables(variables), seqExpr(&seqExpr), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName) {
        if (this->portList) this->portList->parent = this;
        this->variables.parent = this;
        for (auto child : this->variables)
            child->parent = this;
        this->seqExpr->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    explicit SequenceDeclarationSyntax(const SequenceDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CheckerDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token name;
    AssertionItemPortListSyntax* portList;
    Token semi;
    SyntaxList<MemberSyntax> members;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    CheckerDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& members, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::CheckerDeclaration, attributes), keyword(keyword), name(name), portList(portList), semi(semi), members(members), end(end), endBlockName(endBlockName) {
        if (this->portList) this->portList->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    explicit CheckerDeclarationSyntax(const CheckerDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CheckerDataDeclarationSyntax : public MemberSyntax {
    Token rand;
    not_null<DataDeclarationSyntax*> data;

    CheckerDataDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token rand, DataDeclarationSyntax& data) :
        MemberSyntax(SyntaxKind::CheckerDataDeclaration, attributes), rand(rand), data(&data) {
        this->data->parent = this;
    }

    explicit CheckerDataDeclarationSyntax(const CheckerDataDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CompilationUnitSyntax : public SyntaxNode {
    SyntaxList<MemberSyntax> members;
    Token endOfFile;

    CompilationUnitSyntax(const SyntaxList<MemberSyntax>& members, Token endOfFile) :
        SyntaxNode(SyntaxKind::CompilationUnit), members(members), endOfFile(endOfFile) {
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
    }

    explicit CompilationUnitSyntax(const CompilationUnitSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT LibraryMapSyntax : public SyntaxNode {
    SyntaxList<MemberSyntax> members;
    Token endOfFile;

    LibraryMapSyntax(const SyntaxList<MemberSyntax>& members, Token endOfFile) :
        SyntaxNode(SyntaxKind::LibraryMap), members(members), endOfFile(endOfFile) {
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
    }

    explicit LibraryMapSyntax(const LibraryMapSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DirectiveSyntax : public SyntaxNode {
    Token directive;

    DirectiveSyntax(SyntaxKind kind, Token directive) :
        SyntaxNode(kind), directive(directive) {
    }

    explicit DirectiveSyntax(const DirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT SimpleDirectiveSyntax : public DirectiveSyntax {

    SimpleDirectiveSyntax(SyntaxKind kind, Token directive) :
        DirectiveSyntax(kind, directive) {
    }

    explicit SimpleDirectiveSyntax(const SimpleDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT IncludeDirectiveSyntax : public DirectiveSyntax {
    Token fileName;

    IncludeDirectiveSyntax(Token directive, Token fileName) :
        DirectiveSyntax(SyntaxKind::IncludeDirective, directive), fileName(fileName) {
    }

    explicit IncludeDirectiveSyntax(const IncludeDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConditionalDirectiveExpressionSyntax : public SyntaxNode {

    ConditionalDirectiveExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit ConditionalDirectiveExpressionSyntax(const ConditionalDirectiveExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT NamedConditionalDirectiveExpressionSyntax : public ConditionalDirectiveExpressionSyntax {
    Token name;

    NamedConditionalDirectiveExpressionSyntax(Token name) :
        ConditionalDirectiveExpressionSyntax(SyntaxKind::NamedConditionalDirectiveExpression), name(name) {
    }

    explicit NamedConditionalDirectiveExpressionSyntax(const NamedConditionalDirectiveExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UnaryConditionalDirectiveExpressionSyntax : public ConditionalDirectiveExpressionSyntax {
    Token op;
    not_null<ConditionalDirectiveExpressionSyntax*> operand;

    UnaryConditionalDirectiveExpressionSyntax(Token op, ConditionalDirectiveExpressionSyntax& operand) :
        ConditionalDirectiveExpressionSyntax(SyntaxKind::UnaryConditionalDirectiveExpression), op(op), operand(&operand) {
        this->operand->parent = this;
    }

    explicit UnaryConditionalDirectiveExpressionSyntax(const UnaryConditionalDirectiveExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BinaryConditionalDirectiveExpressionSyntax : public ConditionalDirectiveExpressionSyntax {
    not_null<ConditionalDirectiveExpressionSyntax*> left;
    Token op;
    not_null<ConditionalDirectiveExpressionSyntax*> right;

    BinaryConditionalDirectiveExpressionSyntax(ConditionalDirectiveExpressionSyntax& left, Token op, ConditionalDirectiveExpressionSyntax& right) :
        ConditionalDirectiveExpressionSyntax(SyntaxKind::BinaryConditionalDirectiveExpression), left(&left), op(op), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    explicit BinaryConditionalDirectiveExpressionSyntax(const BinaryConditionalDirectiveExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParenthesizedConditionalDirectiveExpressionSyntax : public ConditionalDirectiveExpressionSyntax {
    Token openParen;
    not_null<ConditionalDirectiveExpressionSyntax*> operand;
    Token closeParen;

    ParenthesizedConditionalDirectiveExpressionSyntax(Token openParen, ConditionalDirectiveExpressionSyntax& operand, Token closeParen) :
        ConditionalDirectiveExpressionSyntax(SyntaxKind::ParenthesizedConditionalDirectiveExpression), openParen(openParen), operand(&operand), closeParen(closeParen) {
        this->operand->parent = this;
    }

    explicit ParenthesizedConditionalDirectiveExpressionSyntax(const ParenthesizedConditionalDirectiveExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConditionalBranchDirectiveSyntax : public DirectiveSyntax {
    not_null<ConditionalDirectiveExpressionSyntax*> expr;
    TokenList disabledTokens;

    ConditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, ConditionalDirectiveExpressionSyntax& expr, const TokenList& disabledTokens) :
        DirectiveSyntax(kind, directive), expr(&expr), disabledTokens(disabledTokens) {
        this->expr->parent = this;
        this->disabledTokens.parent = this;
    }

    explicit ConditionalBranchDirectiveSyntax(const ConditionalBranchDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UnconditionalBranchDirectiveSyntax : public DirectiveSyntax {
    TokenList disabledTokens;

    UnconditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, const TokenList& disabledTokens) :
        DirectiveSyntax(kind, directive), disabledTokens(disabledTokens) {
        this->disabledTokens.parent = this;
    }

    explicit UnconditionalBranchDirectiveSyntax(const UnconditionalBranchDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT MacroArgumentDefaultSyntax : public SyntaxNode {
    Token equals;
    TokenList tokens;

    MacroArgumentDefaultSyntax(Token equals, const TokenList& tokens) :
        SyntaxNode(SyntaxKind::MacroArgumentDefault), equals(equals), tokens(tokens) {
        this->tokens.parent = this;
    }

    explicit MacroArgumentDefaultSyntax(const MacroArgumentDefaultSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT MacroFormalArgumentSyntax : public SyntaxNode {
    Token name;
    MacroArgumentDefaultSyntax* defaultValue;

    MacroFormalArgumentSyntax(Token name, MacroArgumentDefaultSyntax* defaultValue) :
        SyntaxNode(SyntaxKind::MacroFormalArgument), name(name), defaultValue(defaultValue) {
        if (this->defaultValue) this->defaultValue->parent = this;
    }

    explicit MacroFormalArgumentSyntax(const MacroFormalArgumentSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT MacroFormalArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroFormalArgumentSyntax> args;
    Token closeParen;

    MacroFormalArgumentListSyntax(Token openParen, const SeparatedSyntaxList<MacroFormalArgumentSyntax>& args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroFormalArgumentList), openParen(openParen), args(args), closeParen(closeParen) {
        this->args.parent = this;
        for (auto child : this->args)
            child->parent = this;
    }

    explicit MacroFormalArgumentListSyntax(const MacroFormalArgumentListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DefineDirectiveSyntax : public DirectiveSyntax {
    Token name;
    MacroFormalArgumentListSyntax* formalArguments;
    TokenList body;

    DefineDirectiveSyntax(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, const TokenList& body) :
        DirectiveSyntax(SyntaxKind::DefineDirective, directive), name(name), formalArguments(formalArguments), body(body) {
        if (this->formalArguments) this->formalArguments->parent = this;
        this->body.parent = this;
    }

    explicit DefineDirectiveSyntax(const DefineDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT MacroActualArgumentSyntax : public SyntaxNode {
    TokenList tokens;

    MacroActualArgumentSyntax(const TokenList& tokens) :
        SyntaxNode(SyntaxKind::MacroActualArgument), tokens(tokens) {
        this->tokens.parent = this;
    }

    explicit MacroActualArgumentSyntax(const MacroActualArgumentSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT MacroActualArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroActualArgumentSyntax> args;
    Token closeParen;

    MacroActualArgumentListSyntax(Token openParen, const SeparatedSyntaxList<MacroActualArgumentSyntax>& args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroActualArgumentList), openParen(openParen), args(args), closeParen(closeParen) {
        this->args.parent = this;
        for (auto child : this->args)
            child->parent = this;
    }

    explicit MacroActualArgumentListSyntax(const MacroActualArgumentListSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT MacroUsageSyntax : public DirectiveSyntax {
    MacroActualArgumentListSyntax* args;

    MacroUsageSyntax(Token directive, MacroActualArgumentListSyntax* args) :
        DirectiveSyntax(SyntaxKind::MacroUsage, directive), args(args) {
        if (this->args) this->args->parent = this;
    }

    explicit MacroUsageSyntax(const MacroUsageSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT TimeScaleDirectiveSyntax : public DirectiveSyntax {
    Token timeUnit;
    Token slash;
    Token timePrecision;

    TimeScaleDirectiveSyntax(Token directive, Token timeUnit, Token slash, Token timePrecision) :
        DirectiveSyntax(SyntaxKind::TimeScaleDirective, directive), timeUnit(timeUnit), slash(slash), timePrecision(timePrecision) {
    }

    explicit TimeScaleDirectiveSyntax(const TimeScaleDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DefaultNetTypeDirectiveSyntax : public DirectiveSyntax {
    Token netType;

    DefaultNetTypeDirectiveSyntax(Token directive, Token netType) :
        DirectiveSyntax(SyntaxKind::DefaultNetTypeDirective, directive), netType(netType) {
    }

    explicit DefaultNetTypeDirectiveSyntax(const DefaultNetTypeDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UnconnectedDriveDirectiveSyntax : public DirectiveSyntax {
    Token strength;

    UnconnectedDriveDirectiveSyntax(Token directive, Token strength) :
        DirectiveSyntax(SyntaxKind::UnconnectedDriveDirective, directive), strength(strength) {
    }

    explicit UnconnectedDriveDirectiveSyntax(const UnconnectedDriveDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DefaultDecayTimeDirectiveSyntax : public DirectiveSyntax {
    Token time;

    DefaultDecayTimeDirectiveSyntax(Token directive, Token time) :
        DirectiveSyntax(SyntaxKind::DefaultDecayTimeDirective, directive), time(time) {
    }

    explicit DefaultDecayTimeDirectiveSyntax(const DefaultDecayTimeDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT DefaultTriregStrengthDirectiveSyntax : public DirectiveSyntax {
    Token strength;

    DefaultTriregStrengthDirectiveSyntax(Token directive, Token strength) :
        DirectiveSyntax(SyntaxKind::DefaultTriregStrengthDirective, directive), strength(strength) {
    }

    explicit DefaultTriregStrengthDirectiveSyntax(const DefaultTriregStrengthDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT LineDirectiveSyntax : public DirectiveSyntax {
    Token lineNumber;
    Token fileName;
    Token level;

    LineDirectiveSyntax(Token directive, Token lineNumber, Token fileName, Token level) :
        DirectiveSyntax(SyntaxKind::LineDirective, directive), lineNumber(lineNumber), fileName(fileName), level(level) {
    }

    explicit LineDirectiveSyntax(const LineDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT UndefDirectiveSyntax : public DirectiveSyntax {
    Token name;

    UndefDirectiveSyntax(Token directive, Token name) :
        DirectiveSyntax(SyntaxKind::UndefDirective, directive), name(name) {
    }

    explicit UndefDirectiveSyntax(const UndefDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT BeginKeywordsDirectiveSyntax : public DirectiveSyntax {
    Token versionSpecifier;

    BeginKeywordsDirectiveSyntax(Token directive, Token versionSpecifier) :
        DirectiveSyntax(SyntaxKind::BeginKeywordsDirective, directive), versionSpecifier(versionSpecifier) {
    }

    explicit BeginKeywordsDirectiveSyntax(const BeginKeywordsDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PragmaExpressionSyntax : public SyntaxNode {

    PragmaExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit PragmaExpressionSyntax(const PragmaExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT SimplePragmaExpressionSyntax : public PragmaExpressionSyntax {
    Token value;

    SimplePragmaExpressionSyntax(Token value) :
        PragmaExpressionSyntax(SyntaxKind::SimplePragmaExpression), value(value) {
    }

    explicit SimplePragmaExpressionSyntax(const SimplePragmaExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NameValuePragmaExpressionSyntax : public PragmaExpressionSyntax {
    Token name;
    Token equals;
    not_null<PragmaExpressionSyntax*> value;

    NameValuePragmaExpressionSyntax(Token name, Token equals, PragmaExpressionSyntax& value) :
        PragmaExpressionSyntax(SyntaxKind::NameValuePragmaExpression), name(name), equals(equals), value(&value) {
        this->value->parent = this;
    }

    explicit NameValuePragmaExpressionSyntax(const NameValuePragmaExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT NumberPragmaExpressionSyntax : public PragmaExpressionSyntax {
    Token size;
    Token base;
    Token value;

    NumberPragmaExpressionSyntax(Token size, Token base, Token value) :
        PragmaExpressionSyntax(SyntaxKind::NumberPragmaExpression), size(size), base(base), value(value) {
    }

    explicit NumberPragmaExpressionSyntax(const NumberPragmaExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ParenPragmaExpressionSyntax : public PragmaExpressionSyntax {
    Token openParen;
    SeparatedSyntaxList<PragmaExpressionSyntax> values;
    Token closeParen;

    ParenPragmaExpressionSyntax(Token openParen, const SeparatedSyntaxList<PragmaExpressionSyntax>& values, Token closeParen) :
        PragmaExpressionSyntax(SyntaxKind::ParenPragmaExpression), openParen(openParen), values(values), closeParen(closeParen) {
        this->values.parent = this;
        for (auto child : this->values)
            child->parent = this;
    }

    explicit ParenPragmaExpressionSyntax(const ParenPragmaExpressionSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT PragmaDirectiveSyntax : public DirectiveSyntax {
    Token name;
    SeparatedSyntaxList<PragmaExpressionSyntax> args;

    PragmaDirectiveSyntax(Token directive, Token name, const SeparatedSyntaxList<PragmaExpressionSyntax>& args) :
        DirectiveSyntax(SyntaxKind::PragmaDirective, directive), name(name), args(args) {
        this->args.parent = this;
        for (auto child : this->args)
            child->parent = this;
    }

    explicit PragmaDirectiveSyntax(const PragmaDirectiveSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConfigCellIdentifierSyntax : public SyntaxNode {
    Token library;
    Token dot;
    Token cell;

    ConfigCellIdentifierSyntax(Token library, Token dot, Token cell) :
        SyntaxNode(SyntaxKind::ConfigCellIdentifier), library(library), dot(dot), cell(cell) {
    }

    explicit ConfigCellIdentifierSyntax(const ConfigCellIdentifierSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConfigRuleClauseSyntax : public SyntaxNode {

    ConfigRuleClauseSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit ConfigRuleClauseSyntax(const ConfigRuleClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT ConfigLiblistSyntax : public ConfigRuleClauseSyntax {
    Token liblist;
    TokenList libraries;

    ConfigLiblistSyntax(Token liblist, const TokenList& libraries) :
        ConfigRuleClauseSyntax(SyntaxKind::ConfigLiblist), liblist(liblist), libraries(libraries) {
        this->libraries.parent = this;
    }

    explicit ConfigLiblistSyntax(const ConfigLiblistSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConfigUseClauseSyntax : public ConfigRuleClauseSyntax {
    Token use;
    ConfigCellIdentifierSyntax* name;
    ParameterValueAssignmentSyntax* paramAssignments;
    Token colon;
    Token config;

    ConfigUseClauseSyntax(Token use, ConfigCellIdentifierSyntax* name, ParameterValueAssignmentSyntax* paramAssignments, Token colon, Token config) :
        ConfigRuleClauseSyntax(SyntaxKind::ConfigUseClause), use(use), name(name), paramAssignments(paramAssignments), colon(colon), config(config) {
        if (this->name) this->name->parent = this;
        if (this->paramAssignments) this->paramAssignments->parent = this;
    }

    explicit ConfigUseClauseSyntax(const ConfigUseClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConfigRuleSyntax : public SyntaxNode {

    ConfigRuleSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    explicit ConfigRuleSyntax(const ConfigRuleSyntax&) = default;

    static bool isKind(SyntaxKind kind);
};

struct SLANG_EXPORT DefaultConfigRuleSyntax : public ConfigRuleSyntax {
    Token defaultKeyword;
    not_null<ConfigLiblistSyntax*> liblist;
    Token semi;

    DefaultConfigRuleSyntax(Token defaultKeyword, ConfigLiblistSyntax& liblist, Token semi) :
        ConfigRuleSyntax(SyntaxKind::DefaultConfigRule), defaultKeyword(defaultKeyword), liblist(&liblist), semi(semi) {
        this->liblist->parent = this;
    }

    explicit DefaultConfigRuleSyntax(const DefaultConfigRuleSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConfigInstanceIdentifierSyntax : public SyntaxNode {
    Token dot;
    Token name;

    ConfigInstanceIdentifierSyntax(Token dot, Token name) :
        SyntaxNode(SyntaxKind::ConfigInstanceIdentifier), dot(dot), name(name) {
    }

    explicit ConfigInstanceIdentifierSyntax(const ConfigInstanceIdentifierSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT InstanceConfigRuleSyntax : public ConfigRuleSyntax {
    Token instance;
    Token topModule;
    SyntaxList<ConfigInstanceIdentifierSyntax> instanceNames;
    not_null<ConfigRuleClauseSyntax*> ruleClause;
    Token semi;

    InstanceConfigRuleSyntax(Token instance, Token topModule, const SyntaxList<ConfigInstanceIdentifierSyntax>& instanceNames, ConfigRuleClauseSyntax& ruleClause, Token semi) :
        ConfigRuleSyntax(SyntaxKind::InstanceConfigRule), instance(instance), topModule(topModule), instanceNames(instanceNames), ruleClause(&ruleClause), semi(semi) {
        this->instanceNames.parent = this;
        for (auto child : this->instanceNames)
            child->parent = this;
        this->ruleClause->parent = this;
    }

    explicit InstanceConfigRuleSyntax(const InstanceConfigRuleSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT CellConfigRuleSyntax : public ConfigRuleSyntax {
    Token cell;
    not_null<ConfigCellIdentifierSyntax*> name;
    not_null<ConfigRuleClauseSyntax*> ruleClause;
    Token semi;

    CellConfigRuleSyntax(Token cell, ConfigCellIdentifierSyntax& name, ConfigRuleClauseSyntax& ruleClause, Token semi) :
        ConfigRuleSyntax(SyntaxKind::CellConfigRule), cell(cell), name(&name), ruleClause(&ruleClause), semi(semi) {
        this->name->parent = this;
        this->ruleClause->parent = this;
    }

    explicit CellConfigRuleSyntax(const CellConfigRuleSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT ConfigDeclarationSyntax : public MemberSyntax {
    Token config;
    Token name;
    Token semi1;
    SyntaxList<ParameterDeclarationStatementSyntax> localparams;
    Token design;
    SyntaxList<ConfigCellIdentifierSyntax> topCells;
    Token semi2;
    SyntaxList<ConfigRuleSyntax> rules;
    Token endconfig;
    NamedBlockClauseSyntax* blockName;

    ConfigDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token config, Token name, Token semi1, const SyntaxList<ParameterDeclarationStatementSyntax>& localparams, Token design, const SyntaxList<ConfigCellIdentifierSyntax>& topCells, Token semi2, const SyntaxList<ConfigRuleSyntax>& rules, Token endconfig, NamedBlockClauseSyntax* blockName) :
        MemberSyntax(SyntaxKind::ConfigDeclaration, attributes), config(config), name(name), semi1(semi1), localparams(localparams), design(design), topCells(topCells), semi2(semi2), rules(rules), endconfig(endconfig), blockName(blockName) {
        this->localparams.parent = this;
        for (auto child : this->localparams)
            child->parent = this;
        this->topCells.parent = this;
        for (auto child : this->topCells)
            child->parent = this;
        this->rules.parent = this;
        for (auto child : this->rules)
            child->parent = this;
        if (this->blockName) this->blockName->parent = this;
    }

    explicit ConfigDeclarationSyntax(const ConfigDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT FilePathSpecSyntax : public SyntaxNode {
    Token path;

    FilePathSpecSyntax(Token path) :
        SyntaxNode(SyntaxKind::FilePathSpec), path(path) {
    }

    explicit FilePathSpecSyntax(const FilePathSpecSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT LibraryIncDirClauseSyntax : public SyntaxNode {
    Token minus;
    Token incdir;
    SeparatedSyntaxList<FilePathSpecSyntax> filePaths;

    LibraryIncDirClauseSyntax(Token minus, Token incdir, const SeparatedSyntaxList<FilePathSpecSyntax>& filePaths) :
        SyntaxNode(SyntaxKind::LibraryIncDirClause), minus(minus), incdir(incdir), filePaths(filePaths) {
        this->filePaths.parent = this;
        for (auto child : this->filePaths)
            child->parent = this;
    }

    explicit LibraryIncDirClauseSyntax(const LibraryIncDirClauseSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT LibraryDeclarationSyntax : public MemberSyntax {
    Token library;
    Token name;
    SeparatedSyntaxList<FilePathSpecSyntax> filePaths;
    LibraryIncDirClauseSyntax* incDirClause;
    Token semi;

    LibraryDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token library, Token name, const SeparatedSyntaxList<FilePathSpecSyntax>& filePaths, LibraryIncDirClauseSyntax* incDirClause, Token semi) :
        MemberSyntax(SyntaxKind::LibraryDeclaration, attributes), library(library), name(name), filePaths(filePaths), incDirClause(incDirClause), semi(semi) {
        this->filePaths.parent = this;
        for (auto child : this->filePaths)
            child->parent = this;
        if (this->incDirClause) this->incDirClause->parent = this;
    }

    explicit LibraryDeclarationSyntax(const LibraryDeclarationSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

struct SLANG_EXPORT LibraryIncludeStatementSyntax : public MemberSyntax {
    Token include;
    not_null<FilePathSpecSyntax*> filePath;
    Token semi;

    LibraryIncludeStatementSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token include, FilePathSpecSyntax& filePath, Token semi) :
        MemberSyntax(SyntaxKind::LibraryIncludeStatement, attributes), include(include), filePath(&filePath), semi(semi) {
        this->filePath->parent = this;
    }

    explicit LibraryIncludeStatementSyntax(const LibraryIncludeStatementSyntax&) = default;

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(size_t index);
    ConstTokenOrSyntax getChild(size_t index) const;
    PtrTokenOrSyntax getChildPtr(size_t index);
    void setChild(size_t index, TokenOrSyntax child);

};

class SLANG_EXPORT SyntaxFactory {
public:
    using Token = parsing::Token;

    explicit SyntaxFactory(BumpAllocator& alloc) : alloc(alloc) {}

    AcceptOnPropertyExprSyntax& acceptOnPropertyExpr(Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, PropertyExprSyntax& expr);
    ActionBlockSyntax& actionBlock(StatementSyntax* statement, ElseClauseSyntax* elseClause);
    AnonymousProgramSyntax& anonymousProgram(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token semi, const SyntaxList<MemberSyntax>& members, Token endkeyword);
    AnsiPortListSyntax& ansiPortList(Token openParen, const SeparatedSyntaxList<MemberSyntax>& ports, Token closeParen);
    AnsiUdpPortListSyntax& ansiUdpPortList(Token openParen, const SeparatedSyntaxList<UdpPortDeclSyntax>& ports, Token closeParen, Token semi);
    ArgumentListSyntax& argumentList(Token openParen, const SeparatedSyntaxList<ArgumentSyntax>& parameters, Token closeParen);
    ArrayOrRandomizeMethodExpressionSyntax& arrayOrRandomizeMethodExpression(ExpressionSyntax& method, Token with, ParenExpressionListSyntax* args, ConstraintBlockSyntax* constraints);
    AssertionItemPortListSyntax& assertionItemPortList(Token openParen, const SeparatedSyntaxList<AssertionItemPortSyntax>& ports, Token closeParen);
    AssertionItemPortSyntax& assertionItemPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token local, Token direction, DataTypeSyntax& type, Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, EqualsAssertionArgClauseSyntax* defaultValue);
    AssignmentPatternExpressionSyntax& assignmentPatternExpression(DataTypeSyntax* type, AssignmentPatternSyntax& pattern);
    AssignmentPatternItemSyntax& assignmentPatternItem(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr);
    AttributeInstanceSyntax& attributeInstance(Token openParen, Token openStar, const SeparatedSyntaxList<AttributeSpecSyntax>& specs, Token closeStar, Token closeParen);
    AttributeSpecSyntax& attributeSpec(Token name, EqualsValueClauseSyntax* value);
    BadExpressionSyntax& badExpression(ExpressionSyntax& expr);
    BeginKeywordsDirectiveSyntax& beginKeywordsDirective(Token directive, Token versionSpecifier);
    BinSelectWithFilterExprSyntax& binSelectWithFilterExpr(BinsSelectExpressionSyntax& expr, Token with, Token openParen, ExpressionSyntax& filter, Token closeParen, MatchesClauseSyntax* matchesClause);
    BinaryBinsSelectExprSyntax& binaryBinsSelectExpr(BinsSelectExpressionSyntax& left, Token op, BinsSelectExpressionSyntax& right);
    BinaryBlockEventExpressionSyntax& binaryBlockEventExpression(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right);
    BinaryConditionalDirectiveExpressionSyntax& binaryConditionalDirectiveExpression(ConditionalDirectiveExpressionSyntax& left, Token op, ConditionalDirectiveExpressionSyntax& right);
    BinaryEventExpressionSyntax& binaryEventExpression(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right);
    BinaryExpressionSyntax& binaryExpression(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& right);
    BinaryPropertyExprSyntax& binaryPropertyExpr(SyntaxKind kind, PropertyExprSyntax& left, Token op, PropertyExprSyntax& right);
    BinarySequenceExprSyntax& binarySequenceExpr(SyntaxKind kind, SequenceExprSyntax& left, Token op, SequenceExprSyntax& right);
    BindDirectiveSyntax& bindDirective(const SyntaxList<AttributeInstanceSyntax>& attributes, Token bind, NameSyntax& target, BindTargetListSyntax* targetInstances, MemberSyntax& instantiation);
    BindTargetListSyntax& bindTargetList(Token colon, const SeparatedSyntaxList<NameSyntax>& targets);
    BinsSelectConditionExprSyntax& binsSelectConditionExpr(Token binsof, Token openParen, NameSyntax& name, Token closeParen, IntersectClauseSyntax* intersects);
    BinsSelectionSyntax& binsSelection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, Token equals, BinsSelectExpressionSyntax& expr, CoverageIffClauseSyntax* iff, Token semi);
    BitSelectSyntax& bitSelect(ExpressionSyntax& expr);
    BlockCoverageEventSyntax& blockCoverageEvent(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen);
    BlockStatementSyntax& blockStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token begin, NamedBlockClauseSyntax* blockName, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName);
    CaseGenerateSyntax& caseGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, const SyntaxList<CaseItemSyntax>& items, Token endCase);
    CasePropertyExprSyntax& casePropertyExpr(Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, const SyntaxList<PropertyCaseItemSyntax>& items, Token endcase);
    CaseStatementSyntax& caseStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, const SyntaxList<CaseItemSyntax>& items, Token endcase);
    CastExpressionSyntax& castExpression(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right);
    CellConfigRuleSyntax& cellConfigRule(Token cell, ConfigCellIdentifierSyntax& name, ConfigRuleClauseSyntax& ruleClause, Token semi);
    ChargeStrengthSyntax& chargeStrength(Token openParen, Token strength, Token closeParen);
    CheckerDataDeclarationSyntax& checkerDataDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token rand, DataDeclarationSyntax& data);
    CheckerDeclarationSyntax& checkerDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& members, Token end, NamedBlockClauseSyntax* endBlockName);
    CheckerInstanceStatementSyntax& checkerInstanceStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, CheckerInstantiationSyntax& instance);
    CheckerInstantiationSyntax& checkerInstantiation(const SyntaxList<AttributeInstanceSyntax>& attributes, NameSyntax& type, ParameterValueAssignmentSyntax* parameters, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi);
    ClassDeclarationSyntax& classDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token virtualOrInterface, Token classKeyword, ClassSpecifierSyntax* finalSpecifier, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, const SyntaxList<MemberSyntax>& items, Token endClass, NamedBlockClauseSyntax* endBlockName);
    ClassMethodDeclarationSyntax& classMethodDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionDeclarationSyntax& declaration);
    ClassMethodPrototypeSyntax& classMethodPrototype(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionPrototypeSyntax& prototype, Token semi);
    ClassNameSyntax& className(Token identifier, ParameterValueAssignmentSyntax& parameters);
    ClassPropertyDeclarationSyntax& classPropertyDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, MemberSyntax& declaration);
    ClassSpecifierSyntax& classSpecifier(Token colon, Token keyword);
    ClockingDeclarationSyntax& clockingDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, EventExpressionSyntax& event, Token semi, const SyntaxList<MemberSyntax>& items, Token endClocking, NamedBlockClauseSyntax* endBlockName);
    ClockingDirectionSyntax& clockingDirection(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* outputSkew);
    ClockingItemSyntax& clockingItem(const SyntaxList<AttributeInstanceSyntax>& attributes, ClockingDirectionSyntax& direction, const SeparatedSyntaxList<AttributeSpecSyntax>& decls, Token semi);
    ClockingPropertyExprSyntax& clockingPropertyExpr(TimingControlSyntax& event, PropertyExprSyntax* expr);
    ClockingSequenceExprSyntax& clockingSequenceExpr(TimingControlSyntax& event, SequenceExprSyntax& expr);
    ClockingSkewSyntax& clockingSkew(Token edge, TimingControlSyntax* delay);
    ColonExpressionClauseSyntax& colonExpressionClause(Token colon, ExpressionSyntax& expr);
    CompilationUnitSyntax& compilationUnit(const SyntaxList<MemberSyntax>& members, Token endOfFile);
    ConcatenationExpressionSyntax& concatenationExpression(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeBrace);
    ConcurrentAssertionMemberSyntax& concurrentAssertionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, ConcurrentAssertionStatementSyntax& statement);
    ConcurrentAssertionStatementSyntax& concurrentAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action);
    ConditionalBranchDirectiveSyntax& conditionalBranchDirective(SyntaxKind kind, Token directive, ConditionalDirectiveExpressionSyntax& expr, const TokenList& disabledTokens);
    ConditionalConstraintSyntax& conditionalConstraint(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause);
    ConditionalExpressionSyntax& conditionalExpression(ConditionalPredicateSyntax& predicate, Token question, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right);
    ConditionalPathDeclarationSyntax& conditionalPathDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& predicate, Token closeParen, PathDeclarationSyntax& path);
    ConditionalPatternSyntax& conditionalPattern(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause);
    ConditionalPredicateSyntax& conditionalPredicate(const SeparatedSyntaxList<ConditionalPatternSyntax>& conditions);
    ConditionalPropertyExprSyntax& conditionalPropertyExpr(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, PropertyExprSyntax& expr, ElsePropertyClauseSyntax* elseClause);
    ConditionalStatementSyntax& conditionalStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause);
    ConfigCellIdentifierSyntax& configCellIdentifier(Token library, Token dot, Token cell);
    ConfigDeclarationSyntax& configDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token config, Token name, Token semi1, const SyntaxList<ParameterDeclarationStatementSyntax>& localparams, Token design, const SyntaxList<ConfigCellIdentifierSyntax>& topCells, Token semi2, const SyntaxList<ConfigRuleSyntax>& rules, Token endconfig, NamedBlockClauseSyntax* blockName);
    ConfigInstanceIdentifierSyntax& configInstanceIdentifier(Token dot, Token name);
    ConfigLiblistSyntax& configLiblist(Token liblist, const TokenList& libraries);
    ConfigUseClauseSyntax& configUseClause(Token use, ConfigCellIdentifierSyntax* name, ParameterValueAssignmentSyntax* paramAssignments, Token colon, Token config);
    ConstraintBlockSyntax& constraintBlock(Token openBrace, const SyntaxList<ConstraintItemSyntax>& items, Token closeBrace);
    ConstraintDeclarationSyntax& constraintDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, const SyntaxList<ClassSpecifierSyntax>& specifiers, NameSyntax& name, ConstraintBlockSyntax& block);
    ConstraintPrototypeSyntax& constraintPrototype(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, const SyntaxList<ClassSpecifierSyntax>& specifiers, NameSyntax& name, Token semi);
    ContinuousAssignSyntax& continuousAssign(const SyntaxList<AttributeInstanceSyntax>& attributes, Token assign, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<ExpressionSyntax>& assignments, Token semi);
    CopyClassExpressionSyntax& copyClassExpression(NameSyntax& scopedNew, ExpressionSyntax& expr);
    CoverCrossSyntax& coverCross(const SyntaxList<AttributeInstanceSyntax>& attributes, NamedLabelSyntax* label, Token cross, const SeparatedSyntaxList<IdentifierNameSyntax>& items, CoverageIffClauseSyntax* iff, Token openBrace, const SyntaxList<MemberSyntax>& members, Token closeBrace, Token emptySemi);
    CoverageBinsArraySizeSyntax& coverageBinsArraySize(Token openBracket, ExpressionSyntax* expr, Token closeBracket);
    CoverageBinsSyntax& coverageBins(const SyntaxList<AttributeInstanceSyntax>& attributes, Token wildcard, Token keyword, Token name, CoverageBinsArraySizeSyntax* size, Token equals, CoverageBinInitializerSyntax& initializer, CoverageIffClauseSyntax* iff, Token semi);
    CoverageIffClauseSyntax& coverageIffClause(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen);
    CoverageOptionSyntax& coverageOption(const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr, Token semi);
    CovergroupDeclarationSyntax& covergroupDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token covergroup, Token extends, Token name, FunctionPortListSyntax* portList, SyntaxNode* event, Token semi, const SyntaxList<MemberSyntax>& members, Token endgroup, NamedBlockClauseSyntax* endBlockName);
    CoverpointSyntax& coverpoint(const SyntaxList<AttributeInstanceSyntax>& attributes, DataTypeSyntax& type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, CoverageIffClauseSyntax* iff, Token openBrace, const SyntaxList<MemberSyntax>& members, Token closeBrace, Token emptySemi);
    DPIExportSyntax& dPIExport(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token specString, Token c_identifier, Token equals, Token functionOrTask, Token name, Token semi);
    DPIImportSyntax& dPIImport(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token specString, Token property, Token c_identifier, Token equals, FunctionPrototypeSyntax& method, Token semi);
    DataDeclarationSyntax& dataDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& modifiers, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
    DeclaratorSyntax& declarator(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, EqualsValueClauseSyntax* initializer);
    DefParamAssignmentSyntax& defParamAssignment(NameSyntax& name, EqualsValueClauseSyntax& setter);
    DefParamSyntax& defParam(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defparam, const SeparatedSyntaxList<DefParamAssignmentSyntax>& assignments, Token semi);
    DefaultCaseItemSyntax& defaultCaseItem(Token defaultKeyword, Token colon, SyntaxNode& clause);
    DefaultClockingReferenceSyntax& defaultClockingReference(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defaultKeyword, Token clocking, Token name, Token semi);
    DefaultConfigRuleSyntax& defaultConfigRule(Token defaultKeyword, ConfigLiblistSyntax& liblist, Token semi);
    DefaultCoverageBinInitializerSyntax& defaultCoverageBinInitializer(Token defaultKeyword, Token sequenceKeyword);
    DefaultDecayTimeDirectiveSyntax& defaultDecayTimeDirective(Token directive, Token time);
    DefaultDisableDeclarationSyntax& defaultDisableDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defaultKeyword, Token disableKeyword, Token iffKeyword, ExpressionSyntax& expr, Token semi);
    DefaultDistItemSyntax& defaultDistItem(Token defaultKeyword, DistWeightSyntax* weight);
    DefaultExtendsClauseArgSyntax& defaultExtendsClauseArg(Token openParen, Token defaultKeyword, Token closeParen);
    DefaultFunctionPortSyntax& defaultFunctionPort(Token keyword);
    DefaultNetTypeDirectiveSyntax& defaultNetTypeDirective(Token directive, Token netType);
    DefaultPropertyCaseItemSyntax& defaultPropertyCaseItem(Token defaultKeyword, Token colon, PropertyExprSyntax& expr, Token semi);
    DefaultRsCaseItemSyntax& defaultRsCaseItem(Token defaultKeyword, Token colon, RsProdItemSyntax& item, Token semi);
    DefaultSkewItemSyntax& defaultSkewItem(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ClockingDirectionSyntax& direction, Token semi);
    DefaultTriregStrengthDirectiveSyntax& defaultTriregStrengthDirective(Token directive, Token strength);
    DeferredAssertionSyntax& deferredAssertion(Token hash, Token zero, Token finalKeyword);
    DefineDirectiveSyntax& defineDirective(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, const TokenList& body);
    Delay3Syntax& delay3(Token hash, Token openParen, ExpressionSyntax& delay1, Token comma1, ExpressionSyntax* delay2, Token comma2, ExpressionSyntax* delay3, Token closeParen);
    DelaySyntax& delay(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue);
    DelayedSequenceElementSyntax& delayedSequenceElement(Token doubleHash, ExpressionSyntax* delayVal, Token openBracket, Token op, SelectorSyntax* range, Token closeBracket, SequenceExprSyntax& expr);
    DelayedSequenceExprSyntax& delayedSequenceExpr(SequenceExprSyntax* first, const SyntaxList<DelayedSequenceElementSyntax>& elements);
    DisableConstraintSyntax& disableConstraint(Token disable, Token soft, ExpressionSyntax& name, Token semi);
    DisableForkStatementSyntax& disableForkStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, Token fork, Token semi);
    DisableIffSyntax& disableIff(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen);
    DisableStatementSyntax& disableStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, NameSyntax& name, Token semi);
    DistConstraintListSyntax& distConstraintList(Token dist, Token openBrace, const SeparatedSyntaxList<DistItemBaseSyntax>& items, Token closeBrace);
    DistItemSyntax& distItem(ExpressionSyntax& range, DistWeightSyntax* weight);
    DistWeightSyntax& distWeight(Token op, Token extraOp, ExpressionSyntax& expr);
    DividerClauseSyntax& dividerClause(Token divide, Token value);
    DoWhileStatementSyntax& doWhileStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi);
    DotMemberClauseSyntax& dotMemberClause(Token dot, Token member);
    DriveStrengthSyntax& driveStrength(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen);
    EdgeControlSpecifierSyntax& edgeControlSpecifier(Token openBracket, const SeparatedSyntaxList<EdgeDescriptorSyntax>& descriptors, Token closeBracket);
    EdgeDescriptorSyntax& edgeDescriptor(Token t1, Token t2);
    EdgeSensitivePathSuffixSyntax& edgeSensitivePathSuffix(Token openParen, const SeparatedSyntaxList<NameSyntax>& outputs, Token polarityOperator, Token colon, ExpressionSyntax& expr, Token closeParen);
    ElabSystemTaskSyntax& elabSystemTask(const SyntaxList<AttributeInstanceSyntax>& attributes, Token name, ArgumentListSyntax* arguments, Token semi);
    ElementSelectExpressionSyntax& elementSelectExpression(ExpressionSyntax& left, ElementSelectSyntax& select);
    ElementSelectSyntax& elementSelect(Token openBracket, SelectorSyntax* selector, Token closeBracket);
    ElseClauseSyntax& elseClause(Token elseKeyword, SyntaxNode& clause);
    ElseConstraintClauseSyntax& elseConstraintClause(Token elseKeyword, ConstraintItemSyntax& constraints);
    ElsePropertyClauseSyntax& elsePropertyClause(Token elseKeyword, PropertyExprSyntax& expr);
    EmptyArgumentSyntax& emptyArgument(Token placeholder);
    EmptyIdentifierNameSyntax& emptyIdentifierName(Token placeholder);
    EmptyMemberSyntax& emptyMember(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token semi);
    EmptyNonAnsiPortSyntax& emptyNonAnsiPort(Token placeholder);
    EmptyPortConnectionSyntax& emptyPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token placeholder);
    EmptyQueueExpressionSyntax& emptyQueueExpression(Token openBrace, Token closeBrace);
    EmptyStatementSyntax& emptyStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token semicolon);
    EmptyTimingCheckArgSyntax& emptyTimingCheckArg(Token placeholder);
    EnumTypeSyntax& enumType(Token keyword, DataTypeSyntax* baseType, Token openBrace, const SeparatedSyntaxList<DeclaratorSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions);
    EqualsAssertionArgClauseSyntax& equalsAssertionArgClause(Token equals, PropertyExprSyntax& expr);
    EqualsTypeClauseSyntax& equalsTypeClause(Token equals, DataTypeSyntax& type);
    EqualsValueClauseSyntax& equalsValueClause(Token equals, ExpressionSyntax& expr);
    EventControlSyntax& eventControl(Token at, ExpressionSyntax& eventName);
    EventControlWithExpressionSyntax& eventControlWithExpression(Token at, EventExpressionSyntax& expr);
    EventTriggerStatementSyntax& eventTriggerStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name, Token semi);
    ExplicitAnsiPortSyntax& explicitAnsiPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    ExplicitNonAnsiPortSyntax& explicitNonAnsiPort(Token dot, Token name, Token openParen, PortExpressionSyntax* expr, Token closeParen);
    ExpressionConstraintSyntax& expressionConstraint(Token soft, ExpressionSyntax& expr, Token semi);
    ExpressionCoverageBinInitializerSyntax& expressionCoverageBinInitializer(ExpressionSyntax& expr);
    ExpressionOrDistSyntax& expressionOrDist(ExpressionSyntax& expr, DistConstraintListSyntax& distribution);
    ExpressionPatternSyntax& expressionPattern(ExpressionSyntax& expr);
    ExpressionStatementSyntax& expressionStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr, Token semi);
    ExpressionTimingCheckArgSyntax& expressionTimingCheckArg(ExpressionSyntax& expr);
    ExtendsClauseSyntax& extendsClause(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments, DefaultExtendsClauseArgSyntax* defaultedArg);
    ExternInterfaceMethodSyntax& externInterfaceMethod(const SyntaxList<AttributeInstanceSyntax>& attributes, Token externKeyword, Token forkJoin, FunctionPrototypeSyntax& prototype, Token semi);
    ExternModuleDeclSyntax& externModuleDecl(const SyntaxList<AttributeInstanceSyntax>& attributes, Token externKeyword, const SyntaxList<AttributeInstanceSyntax>& actualAttributes, ModuleHeaderSyntax& header);
    ExternUdpDeclSyntax& externUdpDecl(const SyntaxList<AttributeInstanceSyntax>& attributes, Token externKeyword, const SyntaxList<AttributeInstanceSyntax>& actualAttributes, Token primitive, Token name, UdpPortListSyntax& portList);
    FilePathSpecSyntax& filePathSpec(Token path);
    FirstMatchSequenceExprSyntax& firstMatchSequenceExpr(Token first_match, Token openParen, SequenceExprSyntax& expr, SequenceMatchListSyntax* matchList, Token closeParen);
    ForLoopStatementSyntax& forLoopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token forKeyword, Token openParen, const SeparatedSyntaxList<SyntaxNode>& initializers, Token semi1, ExpressionSyntax* stopExpr, Token semi2, const SeparatedSyntaxList<ExpressionSyntax>& steps, Token closeParen, StatementSyntax& statement);
    ForVariableDeclarationSyntax& forVariableDeclaration(Token varKeyword, DataTypeSyntax* type, DeclaratorSyntax& declarator);
    ForeachLoopListSyntax& foreachLoopList(Token openParen, NameSyntax& arrayName, Token openBracket, const SeparatedSyntaxList<NameSyntax>& loopVariables, Token closeBracket, Token closeParen);
    ForeachLoopStatementSyntax& foreachLoopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement);
    ForeverStatementSyntax& foreverStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token foreverKeyword, StatementSyntax& statement);
    ForwardTypeRestrictionSyntax& forwardTypeRestriction(Token keyword1, Token keyword2);
    ForwardTypedefDeclarationSyntax& forwardTypedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, ForwardTypeRestrictionSyntax* typeRestriction, Token name, Token semi);
    FunctionDeclarationSyntax& functionDeclaration(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, FunctionPrototypeSyntax& prototype, Token semi, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName);
    FunctionPortListSyntax& functionPortList(Token openParen, const SeparatedSyntaxList<FunctionPortBaseSyntax>& ports, Token closeParen);
    FunctionPortSyntax& functionPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token constKeyword, Token direction, Token staticKeyword, Token varKeyword, DataTypeSyntax* dataType, DeclaratorSyntax& declarator);
    FunctionPrototypeSyntax& functionPrototype(Token keyword, const SyntaxList<ClassSpecifierSyntax>& specifiers, Token lifetime, DataTypeSyntax& returnType, NameSyntax& name, FunctionPortListSyntax* portList);
    GenerateBlockSyntax& generateBlock(const SyntaxList<AttributeInstanceSyntax>& attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, const SyntaxList<MemberSyntax>& members, Token end, NamedBlockClauseSyntax* endName);
    GenerateRegionSyntax& generateRegion(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SyntaxList<MemberSyntax>& members, Token endgenerate);
    GenvarDeclarationSyntax& genvarDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& identifiers, Token semi);
    HierarchicalInstanceSyntax& hierarchicalInstance(InstanceNameSyntax* decl, Token openParen, const SeparatedSyntaxList<PortConnectionSyntax>& connections, Token closeParen);
    HierarchyInstantiationSyntax& hierarchyInstantiation(const SyntaxList<AttributeInstanceSyntax>& attributes, Token type, ParameterValueAssignmentSyntax* parameters, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi);
    IdWithExprCoverageBinInitializerSyntax& idWithExprCoverageBinInitializer(Token id, WithClauseSyntax& withClause);
    IdentifierNameSyntax& identifierName(Token identifier);
    IdentifierSelectNameSyntax& identifierSelectName(Token identifier, const SyntaxList<ElementSelectSyntax>& selectors);
    IfGenerateSyntax& ifGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause);
    IfNonePathDeclarationSyntax& ifNonePathDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, PathDeclarationSyntax& path);
    IffEventClauseSyntax& iffEventClause(Token iff, ExpressionSyntax& expr);
    ImmediateAssertionMemberSyntax& immediateAssertionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, ImmediateAssertionStatementSyntax& statement);
    ImmediateAssertionStatementSyntax& immediateAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action);
    ImplementsClauseSyntax& implementsClause(Token keyword, const SeparatedSyntaxList<NameSyntax>& interfaces);
    ImplicationConstraintSyntax& implicationConstraint(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints);
    ImplicitAnsiPortSyntax& implicitAnsiPort(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, DeclaratorSyntax& declarator);
    ImplicitEventControlSyntax& implicitEventControl(Token at, Token openParen, Token star, Token closeParen);
    ImplicitNonAnsiPortSyntax& implicitNonAnsiPort(PortExpressionSyntax& expr);
    ImplicitTypeSyntax& implicitType(Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions, Token placeholder);
    IncludeDirectiveSyntax& includeDirective(Token directive, Token fileName);
    InsideExpressionSyntax& insideExpression(ExpressionSyntax& expr, Token inside, RangeListSyntax& ranges);
    InstanceConfigRuleSyntax& instanceConfigRule(Token instance, Token topModule, const SyntaxList<ConfigInstanceIdentifierSyntax>& instanceNames, ConfigRuleClauseSyntax& ruleClause, Token semi);
    InstanceNameSyntax& instanceName(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions);
    IntegerTypeSyntax& integerType(SyntaxKind kind, Token keyword, Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions);
    IntegerVectorExpressionSyntax& integerVectorExpression(Token size, Token base, Token value);
    InterfacePortHeaderSyntax& interfacePortHeader(Token nameOrKeyword, DotMemberClauseSyntax* modport);
    IntersectClauseSyntax& intersectClause(Token intersect, RangeListSyntax& ranges);
    InvocationExpressionSyntax& invocationExpression(ExpressionSyntax& left, const SyntaxList<AttributeInstanceSyntax>& attributes, ArgumentListSyntax* arguments);
    JumpStatementSyntax& jumpStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token breakOrContinue, Token semi);
    KeywordNameSyntax& keywordName(SyntaxKind kind, Token keyword);
    KeywordTypeSyntax& keywordType(SyntaxKind kind, Token keyword);
    LetDeclarationSyntax& letDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, Token equals, ExpressionSyntax& expr, Token semi);
    LibraryDeclarationSyntax& libraryDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token library, Token name, const SeparatedSyntaxList<FilePathSpecSyntax>& filePaths, LibraryIncDirClauseSyntax* incDirClause, Token semi);
    LibraryIncDirClauseSyntax& libraryIncDirClause(Token minus, Token incdir, const SeparatedSyntaxList<FilePathSpecSyntax>& filePaths);
    LibraryIncludeStatementSyntax& libraryIncludeStatement(const SyntaxList<AttributeInstanceSyntax>& attributes, Token include, FilePathSpecSyntax& filePath, Token semi);
    LibraryMapSyntax& libraryMap(const SyntaxList<MemberSyntax>& members, Token endOfFile);
    LineDirectiveSyntax& lineDirective(Token directive, Token lineNumber, Token fileName, Token level);
    LiteralExpressionSyntax& literalExpression(SyntaxKind kind, Token literal);
    LocalVariableDeclarationSyntax& localVariableDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token var, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
    LoopConstraintSyntax& loopConstraint(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints);
    LoopGenerateSyntax& loopGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block);
    LoopStatementSyntax& loopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement);
    MacroActualArgumentListSyntax& macroActualArgumentList(Token openParen, const SeparatedSyntaxList<MacroActualArgumentSyntax>& args, Token closeParen);
    MacroActualArgumentSyntax& macroActualArgument(const TokenList& tokens);
    MacroArgumentDefaultSyntax& macroArgumentDefault(Token equals, const TokenList& tokens);
    MacroFormalArgumentListSyntax& macroFormalArgumentList(Token openParen, const SeparatedSyntaxList<MacroFormalArgumentSyntax>& args, Token closeParen);
    MacroFormalArgumentSyntax& macroFormalArgument(Token name, MacroArgumentDefaultSyntax* defaultValue);
    MacroUsageSyntax& macroUsage(Token directive, MacroActualArgumentListSyntax* args);
    MatchesClauseSyntax& matchesClause(Token matchesKeyword, PatternSyntax& pattern);
    MemberAccessExpressionSyntax& memberAccessExpression(ExpressionSyntax& left, Token dot, Token name);
    MinTypMaxExpressionSyntax& minTypMaxExpression(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max);
    ModportClockingPortSyntax& modportClockingPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token clocking, Token name);
    ModportDeclarationSyntax& modportDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<ModportItemSyntax>& items, Token semi);
    ModportExplicitPortSyntax& modportExplicitPort(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    ModportItemSyntax& modportItem(Token name, AnsiPortListSyntax& ports);
    ModportNamedPortSyntax& modportNamedPort(Token name);
    ModportSimplePortListSyntax& modportSimplePortList(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, const SeparatedSyntaxList<ModportPortSyntax>& ports);
    ModportSubroutinePortListSyntax& modportSubroutinePortList(const SyntaxList<AttributeInstanceSyntax>& attributes, Token importExport, const SeparatedSyntaxList<ModportPortSyntax>& ports);
    ModportSubroutinePortSyntax& modportSubroutinePort(FunctionPrototypeSyntax& prototype);
    ModuleDeclarationSyntax& moduleDeclaration(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, ModuleHeaderSyntax& header, const SyntaxList<MemberSyntax>& members, Token endmodule, NamedBlockClauseSyntax* blockName);
    ModuleHeaderSyntax& moduleHeader(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, const SyntaxList<PackageImportDeclarationSyntax>& imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi);
    MultipleConcatenationExpressionSyntax& multipleConcatenationExpression(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace);
    NameValuePragmaExpressionSyntax& nameValuePragmaExpression(Token name, Token equals, PragmaExpressionSyntax& value);
    NamedArgumentSyntax& namedArgument(Token dot, Token name, Token openParen, PropertyExprSyntax* expr, Token closeParen);
    NamedBlockClauseSyntax& namedBlockClause(Token colon, Token name);
    NamedConditionalDirectiveExpressionSyntax& namedConditionalDirectiveExpression(Token name);
    NamedLabelSyntax& namedLabel(Token name, Token colon);
    NamedParamAssignmentSyntax& namedParamAssignment(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    NamedPortConnectionSyntax& namedPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dot, Token name, Token openParen, PropertyExprSyntax* expr, Token closeParen);
    NamedStructurePatternMemberSyntax& namedStructurePatternMember(Token name, Token colon, PatternSyntax& pattern);
    NamedTypeSyntax& namedType(NameSyntax& name);
    NetAliasSyntax& netAlias(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<ExpressionSyntax>& nets, Token semi);
    NetDeclarationSyntax& netDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, TimingControlSyntax* delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
    NetPortHeaderSyntax& netPortHeader(Token direction, Token netType, DataTypeSyntax& dataType);
    NetTypeDeclarationSyntax& netTypeDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DataTypeSyntax& type, Token name, WithFunctionClauseSyntax* withFunction, Token semi);
    NewArrayExpressionSyntax& newArrayExpression(NameSyntax& newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer);
    NewClassExpressionSyntax& newClassExpression(NameSyntax& scopedNew, ArgumentListSyntax* argList);
    NonAnsiPortListSyntax& nonAnsiPortList(Token openParen, const SeparatedSyntaxList<NonAnsiPortSyntax>& ports, Token closeParen);
    NonAnsiUdpPortListSyntax& nonAnsiUdpPortList(Token openParen, const SeparatedSyntaxList<IdentifierNameSyntax>& ports, Token closeParen, Token semi);
    NumberPragmaExpressionSyntax& numberPragmaExpression(Token size, Token base, Token value);
    OneStepDelaySyntax& oneStepDelay(Token hash, Token oneStep);
    OrderedArgumentSyntax& orderedArgument(PropertyExprSyntax& expr);
    OrderedParamAssignmentSyntax& orderedParamAssignment(ExpressionSyntax& expr);
    OrderedPortConnectionSyntax& orderedPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, PropertyExprSyntax& expr);
    OrderedStructurePatternMemberSyntax& orderedStructurePatternMember(PatternSyntax& pattern);
    PackageExportAllDeclarationSyntax& packageExportAllDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token star1, Token doubleColon, Token star2, Token semi);
    PackageExportDeclarationSyntax& packageExportDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<PackageImportItemSyntax>& items, Token semi);
    PackageImportDeclarationSyntax& packageImportDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<PackageImportItemSyntax>& items, Token semi);
    PackageImportItemSyntax& packageImportItem(Token package, Token doubleColon, Token item);
    ParameterDeclarationStatementSyntax& parameterDeclarationStatement(const SyntaxList<AttributeInstanceSyntax>& attributes, ParameterDeclarationBaseSyntax& parameter, Token semi);
    ParameterDeclarationSyntax& parameterDeclaration(Token keyword, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators);
    ParameterPortListSyntax& parameterPortList(Token hash, Token openParen, const SeparatedSyntaxList<ParameterDeclarationBaseSyntax>& declarations, Token closeParen);
    ParameterValueAssignmentSyntax& parameterValueAssignment(Token hash, Token openParen, const SeparatedSyntaxList<ParamAssignmentSyntax>& parameters, Token closeParen);
    ParenExpressionListSyntax& parenExpressionList(Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeParen);
    ParenPragmaExpressionSyntax& parenPragmaExpression(Token openParen, const SeparatedSyntaxList<PragmaExpressionSyntax>& values, Token closeParen);
    ParenthesizedBinsSelectExprSyntax& parenthesizedBinsSelectExpr(Token openParen, BinsSelectExpressionSyntax& expr, Token closeParen);
    ParenthesizedConditionalDirectiveExpressionSyntax& parenthesizedConditionalDirectiveExpression(Token openParen, ConditionalDirectiveExpressionSyntax& operand, Token closeParen);
    ParenthesizedEventExpressionSyntax& parenthesizedEventExpression(Token openParen, EventExpressionSyntax& expr, Token closeParen);
    ParenthesizedExpressionSyntax& parenthesizedExpression(Token openParen, ExpressionSyntax& expression, Token closeParen);
    ParenthesizedPatternSyntax& parenthesizedPattern(Token openParen, PatternSyntax& pattern, Token closeParen);
    ParenthesizedPropertyExprSyntax& parenthesizedPropertyExpr(Token openParen, PropertyExprSyntax& expr, SequenceMatchListSyntax* matchList, Token closeParen);
    ParenthesizedSequenceExprSyntax& parenthesizedSequenceExpr(Token openParen, SequenceExprSyntax& expr, SequenceMatchListSyntax* matchList, Token closeParen, SequenceRepetitionSyntax* repetition);
    PathDeclarationSyntax& pathDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, PathDescriptionSyntax& desc, Token equals, Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& delays, Token closeParen, Token semi);
    PathDescriptionSyntax& pathDescription(Token openParen, Token edgeIdentifier, const SeparatedSyntaxList<NameSyntax>& inputs, Token polarityOperator, Token pathOperator, PathSuffixSyntax& suffix, Token closeParen);
    PatternCaseItemSyntax& patternCaseItem(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement);
    PortConcatenationSyntax& portConcatenation(Token openBrace, const SeparatedSyntaxList<PortReferenceSyntax>& references, Token closeBrace);
    PortDeclarationSyntax& portDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
    PortReferenceSyntax& portReference(Token name, ElementSelectSyntax* select);
    PostfixUnaryExpressionSyntax& postfixUnaryExpression(SyntaxKind kind, ExpressionSyntax& operand, const SyntaxList<AttributeInstanceSyntax>& attributes, Token operatorToken);
    PragmaDirectiveSyntax& pragmaDirective(Token directive, Token name, const SeparatedSyntaxList<PragmaExpressionSyntax>& args);
    PrefixUnaryExpressionSyntax& prefixUnaryExpression(SyntaxKind kind, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& operand);
    PrimaryBlockEventExpressionSyntax& primaryBlockEventExpression(Token keyword, NameSyntax& name);
    PrimitiveInstantiationSyntax& primitiveInstantiation(const SyntaxList<AttributeInstanceSyntax>& attributes, Token type, NetStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi);
    ProceduralAssignStatementSyntax& proceduralAssignStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& expr, Token semi);
    ProceduralBlockSyntax& proceduralBlock(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, StatementSyntax& statement);
    ProceduralDeassignStatementSyntax& proceduralDeassignStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& variable, Token semi);
    ProductionSyntax& production(DataTypeSyntax* dataType, Token name, FunctionPortListSyntax* portList, Token colon, const SeparatedSyntaxList<RsRuleSyntax>& rules, Token semi);
    PropertyDeclarationSyntax& propertyDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<LocalVariableDeclarationSyntax>& variables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName);
    PropertySpecSyntax& propertySpec(TimingControlSyntax* clocking, DisableIffSyntax* disable, PropertyExprSyntax& expr);
    PullStrengthSyntax& pullStrength(Token openParen, Token strength, Token closeParen);
    PulseStyleDeclarationSyntax& pulseStyleDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<NameSyntax>& inputs, Token semi);
    QueueDimensionSpecifierSyntax& queueDimensionSpecifier(Token dollar, ColonExpressionClauseSyntax* maxSizeClause);
    RandCaseItemSyntax& randCaseItem(ExpressionSyntax& expr, Token colon, StatementSyntax& statement);
    RandCaseStatementSyntax& randCaseStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token randCase, const SyntaxList<RandCaseItemSyntax>& items, Token endCase);
    RandJoinClauseSyntax& randJoinClause(Token rand, Token join, ParenthesizedExpressionSyntax* expr);
    RandSequenceStatementSyntax& randSequenceStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token randsequence, Token openParen, Token firstProduction, Token closeParen, const SyntaxList<ProductionSyntax>& productions, Token endsequence);
    RangeCoverageBinInitializerSyntax& rangeCoverageBinInitializer(RangeListSyntax& ranges, WithClauseSyntax* withClause);
    RangeDimensionSpecifierSyntax& rangeDimensionSpecifier(SelectorSyntax& selector);
    RangeListSyntax& rangeList(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& valueRanges, Token closeBrace);
    RangeSelectSyntax& rangeSelect(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right);
    RepeatedEventControlSyntax& repeatedEventControl(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl);
    ReplicatedAssignmentPatternSyntax& replicatedAssignmentPattern(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token innerCloseBrace, Token closeBrace);
    ReturnStatementSyntax& returnStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi);
    RsCaseSyntax& rsCase(Token keyword, Token openParen, ExpressionSyntax& expr, Token closeParen, const SyntaxList<RsCaseItemSyntax>& items, Token endcase);
    RsCodeBlockSyntax& rsCodeBlock(Token openBrace, const SyntaxList<SyntaxNode>& items, Token closeBrace);
    RsElseClauseSyntax& rsElseClause(Token keyword, RsProdItemSyntax& item);
    RsIfElseSyntax& rsIfElse(Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, RsProdItemSyntax& ifItem, RsElseClauseSyntax* elseClause);
    RsProdItemSyntax& rsProdItem(Token name, ArgumentListSyntax* argList);
    RsRepeatSyntax& rsRepeat(Token keyword, Token openParen, ExpressionSyntax& expr, Token closeParen, RsProdItemSyntax& item);
    RsRuleSyntax& rsRule(RandJoinClauseSyntax* randJoin, const SyntaxList<RsProdSyntax>& prods, RsWeightClauseSyntax* weightClause);
    RsWeightClauseSyntax& rsWeightClause(Token colonEqual, ExpressionSyntax& weight, RsProdSyntax* codeBlock);
    ScopedNameSyntax& scopedName(NameSyntax& left, Token separator, NameSyntax& right);
    SequenceDeclarationSyntax& sequenceDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<LocalVariableDeclarationSyntax>& variables, SequenceExprSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName);
    SequenceMatchListSyntax& sequenceMatchList(Token comma, const SeparatedSyntaxList<PropertyExprSyntax>& items);
    SequenceRepetitionSyntax& sequenceRepetition(Token openBracket, Token op, SelectorSyntax* selector, Token closeBracket);
    SignalEventExpressionSyntax& signalEventExpression(Token edge, ExpressionSyntax& expr, IffEventClauseSyntax* iffClause);
    SignedCastExpressionSyntax& signedCastExpression(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner);
    SimpleAssignmentPatternSyntax& simpleAssignmentPattern(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token closeBrace);
    SimpleBinsSelectExprSyntax& simpleBinsSelectExpr(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause);
    SimpleDirectiveSyntax& simpleDirective(SyntaxKind kind, Token directive);
    SimplePathSuffixSyntax& simplePathSuffix(const SeparatedSyntaxList<NameSyntax>& outputs);
    SimplePragmaExpressionSyntax& simplePragmaExpression(Token value);
    SimplePropertyExprSyntax& simplePropertyExpr(SequenceExprSyntax& expr);
    SimpleSequenceExprSyntax& simpleSequenceExpr(ExpressionSyntax& expr, SequenceRepetitionSyntax* repetition);
    SolveBeforeConstraintSyntax& solveBeforeConstraint(Token solve, const SeparatedSyntaxList<ExpressionSyntax>& beforeExpr, Token before, const SeparatedSyntaxList<ExpressionSyntax>& afterExpr, Token semi);
    SpecifyBlockSyntax& specifyBlock(const SyntaxList<AttributeInstanceSyntax>& attributes, Token specify, const SyntaxList<MemberSyntax>& items, Token endspecify);
    SpecparamDeclarationSyntax& specparamDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ImplicitTypeSyntax& type, const SeparatedSyntaxList<SpecparamDeclaratorSyntax>& declarators, Token semi);
    SpecparamDeclaratorSyntax& specparamDeclarator(Token name, Token equals, Token openParen, ExpressionSyntax& value1, Token comma, ExpressionSyntax* value2, Token closeParen);
    StandardCaseItemSyntax& standardCaseItem(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, SyntaxNode& clause);
    StandardPropertyCaseItemSyntax& standardPropertyCaseItem(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, PropertyExprSyntax& expr, Token semi);
    StandardRsCaseItemSyntax& standardRsCaseItem(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, RsProdItemSyntax& item, Token semi);
    StreamExpressionSyntax& streamExpression(ExpressionSyntax& expression, StreamExpressionWithRangeSyntax* withRange);
    StreamExpressionWithRangeSyntax& streamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range);
    StreamingConcatenationExpressionSyntax& streamingConcatenationExpression(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, const SeparatedSyntaxList<StreamExpressionSyntax>& expressions, Token innerCloseBrace, Token closeBrace);
    StrongWeakPropertyExprSyntax& strongWeakPropertyExpr(Token keyword, Token openParen, SequenceExprSyntax& expr, Token closeParen);
    StructUnionMemberSyntax& structUnionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, Token randomQualifier, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
    StructUnionTypeSyntax& structUnionType(SyntaxKind kind, Token keyword, Token taggedOrSoft, Token packed, Token signing, Token openBrace, const SyntaxList<StructUnionMemberSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions);
    StructurePatternSyntax& structurePattern(Token openBrace, const SeparatedSyntaxList<StructurePatternMemberSyntax>& members, Token closeBrace);
    StructuredAssignmentPatternSyntax& structuredAssignmentPattern(Token openBrace, const SeparatedSyntaxList<AssignmentPatternItemSyntax>& items, Token closeBrace);
    SuperNewDefaultedArgsExpressionSyntax& superNewDefaultedArgsExpression(NameSyntax& scopedNew, Token openParen, Token defaultKeyword, Token closeParen);
    SystemNameSyntax& systemName(Token systemIdentifier);
    SystemTimingCheckSyntax& systemTimingCheck(const SyntaxList<AttributeInstanceSyntax>& attributes, Token name, Token openParen, const SeparatedSyntaxList<TimingCheckArgSyntax>& args, Token closeParen, Token semi);
    TaggedPatternSyntax& taggedPattern(Token tagged, Token memberName, PatternSyntax* pattern);
    TaggedUnionExpressionSyntax& taggedUnionExpression(Token tagged, Token member, ExpressionSyntax* expr);
    TimeScaleDirectiveSyntax& timeScaleDirective(Token directive, Token timeUnit, Token slash, Token timePrecision);
    TimeUnitsDeclarationSyntax& timeUnitsDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi);
    TimingCheckEventArgSyntax& timingCheckEventArg(Token edge, EdgeControlSpecifierSyntax* controlSpecifier, ExpressionSyntax& terminal, TimingCheckEventConditionSyntax* condition);
    TimingCheckEventConditionSyntax& timingCheckEventCondition(Token tripleAnd, ExpressionSyntax& expr);
    TimingControlExpressionSyntax& timingControlExpression(TimingControlSyntax& timing, ExpressionSyntax& expr);
    TimingControlStatementSyntax& timingControlStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, TimingControlSyntax& timingControl, StatementSyntax& statement);
    TransListCoverageBinInitializerSyntax& transListCoverageBinInitializer(const SeparatedSyntaxList<TransSetSyntax>& sets);
    TransRangeSyntax& transRange(const SeparatedSyntaxList<ExpressionSyntax>& items, TransRepeatRangeSyntax* repeat);
    TransRepeatRangeSyntax& transRepeatRange(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket);
    TransSetSyntax& transSet(Token openParen, const SeparatedSyntaxList<TransRangeSyntax>& ranges, Token closeParen);
    TypeAssignmentSyntax& typeAssignment(Token name, EqualsTypeClauseSyntax* assignment);
    TypeParameterDeclarationSyntax& typeParameterDeclaration(Token keyword, Token typeKeyword, ForwardTypeRestrictionSyntax* typeRestriction, const SeparatedSyntaxList<TypeAssignmentSyntax>& declarators);
    TypeReferenceSyntax& typeReference(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen);
    TypedefDeclarationSyntax& typedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token semi);
    UdpBodySyntax& udpBody(const SeparatedSyntaxList<UdpPortDeclSyntax>& portDecls, UdpInitialStmtSyntax* initialStmt, Token table, const SyntaxList<UdpEntrySyntax>& entries, Token endtable);
    UdpDeclarationSyntax& udpDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token primitive, Token name, UdpPortListSyntax& portList, UdpBodySyntax& body, Token endprimitive, NamedBlockClauseSyntax* endBlockName);
    UdpEdgeFieldSyntax& udpEdgeField(Token openParen, Token first, Token second, Token closeParen);
    UdpEntrySyntax& udpEntry(const SyntaxList<UdpFieldBaseSyntax>& inputs, Token colon1, UdpFieldBaseSyntax* current, Token colon2, UdpFieldBaseSyntax* next, Token semi);
    UdpInitialStmtSyntax& udpInitialStmt(Token initial, Token name, Token equals, ExpressionSyntax& value, Token semi);
    UdpInputPortDeclSyntax& udpInputPortDecl(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& names);
    UdpOutputPortDeclSyntax& udpOutputPortDecl(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token reg, Token name, EqualsValueClauseSyntax* initializer);
    UdpSimpleFieldSyntax& udpSimpleField(Token field);
    UnaryBinsSelectExprSyntax& unaryBinsSelectExpr(Token op, BinsSelectConditionExprSyntax& expr);
    UnaryConditionalDirectiveExpressionSyntax& unaryConditionalDirectiveExpression(Token op, ConditionalDirectiveExpressionSyntax& operand);
    UnaryPropertyExprSyntax& unaryPropertyExpr(Token op, PropertyExprSyntax& expr);
    UnarySelectPropertyExprSyntax& unarySelectPropertyExpr(Token op, Token openBracket, SelectorSyntax* selector, Token closeBracket, PropertyExprSyntax& expr);
    UnconditionalBranchDirectiveSyntax& unconditionalBranchDirective(SyntaxKind kind, Token directive, const TokenList& disabledTokens);
    UnconnectedDriveDirectiveSyntax& unconnectedDriveDirective(Token directive, Token strength);
    UndefDirectiveSyntax& undefDirective(Token directive, Token name);
    UniquenessConstraintSyntax& uniquenessConstraint(Token unique, RangeListSyntax& ranges, Token semi);
    UserDefinedNetDeclarationSyntax& userDefinedNetDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, TimingControlSyntax& delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
    ValueRangeExpressionSyntax& valueRangeExpression(Token openBracket, ExpressionSyntax& left, Token op, ExpressionSyntax& right, Token closeBracket);
    VariableDimensionSyntax& variableDimension(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket);
    VariablePatternSyntax& variablePattern(Token dot, Token variableName);
    VariablePortHeaderSyntax& variablePortHeader(Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax& dataType);
    VirtualInterfaceTypeSyntax& virtualInterfaceType(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport);
    VoidCastedCallStatementSyntax& voidCastedCallStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token voidKeyword, Token apostrophe, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi);
    WaitForkStatementSyntax& waitForkStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token fork, Token semi);
    WaitOrderStatementSyntax& waitOrderStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait_order, Token openParen, const SeparatedSyntaxList<NameSyntax>& names, Token closeParen, ActionBlockSyntax& action);
    WaitStatementSyntax& waitStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement);
    WildcardDimensionSpecifierSyntax& wildcardDimensionSpecifier(Token star);
    WildcardPatternSyntax& wildcardPattern(Token dot, Token star);
    WildcardPortConnectionSyntax& wildcardPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dot, Token star);
    WildcardPortListSyntax& wildcardPortList(Token openParen, Token dot, Token star, Token closeParen);
    WildcardUdpPortListSyntax& wildcardUdpPortList(Token openParen, Token dot, Token star, Token closeParen, Token semi);
    WithClauseSyntax& withClause(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen);
    WithFunctionClauseSyntax& withFunctionClause(Token with, NameSyntax& name);
    WithFunctionSampleSyntax& withFunctionSample(Token with, Token function, Token sample, FunctionPortListSyntax* portList);

private:
    BumpAllocator& alloc;
};

namespace detail {

struct InvalidSyntaxNode : public SyntaxNode {
    static bool isKind(SyntaxKind kind) { return kind == SyntaxKind::Unknown; }
    TokenOrSyntax getChild(size_t) { return nullptr; }
    ConstTokenOrSyntax getChild(size_t) const { return nullptr; }
    PtrTokenOrSyntax getChildPtr(size_t) { return nullptr; }
    void setChild(size_t, TokenOrSyntax) {}
};

template<typename TNode, typename TVisitor, typename... Args>
decltype(auto) visitSyntaxNode(TNode* node, TVisitor& visitor, Args&&... args) {
    static constexpr bool isConst = std::is_const_v<TNode>;    switch (node->kind) {
        case SyntaxKind::Unknown: return visitor.visit(*static_cast<std::conditional_t<isConst, const InvalidSyntaxNode*, InvalidSyntaxNode*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SyntaxList:
        case SyntaxKind::TokenList:
        case SyntaxKind::SeparatedList:
            return visitor.visit(*static_cast<std::conditional_t<isConst, const SyntaxListBase*, SyntaxListBase*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AcceptOnPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const AcceptOnPropertyExprSyntax*, AcceptOnPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ActionBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ActionBlockSyntax*, ActionBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AddAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AddExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysCombBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysFFBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysLatchBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AndAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AndPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryPropertyExprSyntax*, BinaryPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AndSequenceExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinarySequenceExprSyntax*, BinarySequenceExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AnonymousProgram: return visitor.visit(*static_cast<std::conditional_t<isConst, const AnonymousProgramSyntax*, AnonymousProgramSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AnsiPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AnsiPortListSyntax*, AnsiPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AnsiUdpPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AnsiUdpPortListSyntax*, AnsiUdpPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ArgumentListSyntax*, ArgumentListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticShiftLeftExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticShiftRightExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayAndMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayOrMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayOrRandomizeMethodExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ArrayOrRandomizeMethodExpressionSyntax*, ArrayOrRandomizeMethodExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayUniqueMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayXorMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AscendingRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssertPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssertionItemPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssertionItemPortSyntax*, AssertionItemPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssertionItemPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssertionItemPortListSyntax*, AssertionItemPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssignmentPatternExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssignmentPatternExpressionSyntax*, AssignmentPatternExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssignmentPatternItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssignmentPatternItemSyntax*, AssignmentPatternItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssumePropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AttributeInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const AttributeInstanceSyntax*, AttributeInstanceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AttributeSpec: return visitor.visit(*static_cast<std::conditional_t<isConst, const AttributeSpecSyntax*, AttributeSpecSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BadExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BadExpressionSyntax*, BadExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BeginKeywordsDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const BeginKeywordsDirectiveSyntax*, BeginKeywordsDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinSelectWithFilterExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinSelectWithFilterExprSyntax*, BinSelectWithFilterExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryBinsSelectExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryBinsSelectExprSyntax*, BinaryBinsSelectExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryBlockEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryBlockEventExpressionSyntax*, BinaryBlockEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryConditionalDirectiveExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryConditionalDirectiveExpressionSyntax*, BinaryConditionalDirectiveExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryEventExpressionSyntax*, BinaryEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryXnorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryXorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BindDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const BindDirectiveSyntax*, BindDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BindTargetList: return visitor.visit(*static_cast<std::conditional_t<isConst, const BindTargetListSyntax*, BindTargetListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinsSelectConditionExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinsSelectConditionExprSyntax*, BinsSelectConditionExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinsSelection: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinsSelectionSyntax*, BinsSelectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BitSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const BitSelectSyntax*, BitSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BitType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BlockCoverageEvent: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockCoverageEventSyntax*, BlockCoverageEventSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BlockingEventTriggerStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventTriggerStatementSyntax*, EventTriggerStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ByteType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CHandleType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseEqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const CaseGenerateSyntax*, CaseGenerateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseInequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CasePropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const CasePropertyExprSyntax*, CasePropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const CaseStatementSyntax*, CaseStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CastExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const CastExpressionSyntax*, CastExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CellConfigRule: return visitor.visit(*static_cast<std::conditional_t<isConst, const CellConfigRuleSyntax*, CellConfigRuleSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CellDefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ChargeStrength: return visitor.visit(*static_cast<std::conditional_t<isConst, const ChargeStrengthSyntax*, ChargeStrengthSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CheckerDataDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const CheckerDataDeclarationSyntax*, CheckerDataDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CheckerDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const CheckerDeclarationSyntax*, CheckerDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CheckerInstanceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const CheckerInstanceStatementSyntax*, CheckerInstanceStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CheckerInstantiation: return visitor.visit(*static_cast<std::conditional_t<isConst, const CheckerInstantiationSyntax*, CheckerInstantiationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassDeclarationSyntax*, ClassDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassMethodDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassMethodDeclarationSyntax*, ClassMethodDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassMethodPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassMethodPrototypeSyntax*, ClassMethodPrototypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassName: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassNameSyntax*, ClassNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassPropertyDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassPropertyDeclarationSyntax*, ClassPropertyDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassSpecifierSyntax*, ClassSpecifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingDeclarationSyntax*, ClockingDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingDirection: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingDirectionSyntax*, ClockingDirectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingItemSyntax*, ClockingItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingPropertyExprSyntax*, ClockingPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingSequenceExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingSequenceExprSyntax*, ClockingSequenceExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingSkew: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingSkewSyntax*, ClockingSkewSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ColonExpressionClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ColonExpressionClauseSyntax*, ColonExpressionClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CompilationUnit: return visitor.visit(*static_cast<std::conditional_t<isConst, const CompilationUnitSyntax*, CompilationUnitSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcatenationExpressionSyntax*, ConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConcurrentAssertionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionMemberSyntax*, ConcurrentAssertionMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalConstraintSyntax*, ConditionalConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalExpressionSyntax*, ConditionalExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalPathDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPathDeclarationSyntax*, ConditionalPathDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPatternSyntax*, ConditionalPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalPredicate: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPredicateSyntax*, ConditionalPredicateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPropertyExprSyntax*, ConditionalPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalStatementSyntax*, ConditionalStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConfigCellIdentifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConfigCellIdentifierSyntax*, ConfigCellIdentifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConfigDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConfigDeclarationSyntax*, ConfigDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConfigInstanceIdentifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConfigInstanceIdentifierSyntax*, ConfigInstanceIdentifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConfigLiblist: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConfigLiblistSyntax*, ConfigLiblistSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConfigUseClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConfigUseClauseSyntax*, ConfigUseClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstraintBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintBlockSyntax*, ConstraintBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstraintDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintDeclarationSyntax*, ConstraintDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstraintPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintPrototypeSyntax*, ConstraintPrototypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstructorName: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ContinuousAssign: return visitor.visit(*static_cast<std::conditional_t<isConst, const ContinuousAssignSyntax*, ContinuousAssignSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CopyClassExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const CopyClassExpressionSyntax*, CopyClassExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverCross: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverCrossSyntax*, CoverCrossSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverSequenceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverageBins: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageBinsSyntax*, CoverageBinsSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverageBinsArraySize: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageBinsArraySizeSyntax*, CoverageBinsArraySizeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverageIffClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageIffClauseSyntax*, CoverageIffClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverageOption: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageOptionSyntax*, CoverageOptionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CovergroupDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const CovergroupDeclarationSyntax*, CovergroupDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::Coverpoint: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverpointSyntax*, CoverpointSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CycleDelay: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelaySyntax*, DelaySyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DPIExport: return visitor.visit(*static_cast<std::conditional_t<isConst, const DPIExportSyntax*, DPIExportSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DPIImport: return visitor.visit(*static_cast<std::conditional_t<isConst, const DPIImportSyntax*, DPIImportSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DataDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const DataDeclarationSyntax*, DataDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::Declarator: return visitor.visit(*static_cast<std::conditional_t<isConst, const DeclaratorSyntax*, DeclaratorSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefParam: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefParamSyntax*, DefParamSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefParamAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefParamAssignmentSyntax*, DefParamAssignmentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultCaseItemSyntax*, DefaultCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultClockingReference: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultClockingReferenceSyntax*, DefaultClockingReferenceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultConfigRule: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultConfigRuleSyntax*, DefaultConfigRuleSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultCoverageBinInitializerSyntax*, DefaultCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultDecayTimeDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultDecayTimeDirectiveSyntax*, DefaultDecayTimeDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultDisableDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultDisableDeclarationSyntax*, DefaultDisableDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultDistItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultDistItemSyntax*, DefaultDistItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultExtendsClauseArg: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultExtendsClauseArgSyntax*, DefaultExtendsClauseArgSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultFunctionPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultFunctionPortSyntax*, DefaultFunctionPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultNetTypeDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultNetTypeDirectiveSyntax*, DefaultNetTypeDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultPatternKeyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultPropertyCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultPropertyCaseItemSyntax*, DefaultPropertyCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultRsCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultRsCaseItemSyntax*, DefaultRsCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultSkewItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultSkewItemSyntax*, DefaultSkewItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultTriregStrengthDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultTriregStrengthDirectiveSyntax*, DefaultTriregStrengthDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DeferredAssertion: return visitor.visit(*static_cast<std::conditional_t<isConst, const DeferredAssertionSyntax*, DeferredAssertionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefineDirectiveSyntax*, DefineDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::Delay3: return visitor.visit(*static_cast<std::conditional_t<isConst, const Delay3Syntax*, Delay3Syntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DelayControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelaySyntax*, DelaySyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DelayModeDistributedDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DelayModePathDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DelayModeUnitDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DelayModeZeroDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DelayedSequenceElement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelayedSequenceElementSyntax*, DelayedSequenceElementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DelayedSequenceExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelayedSequenceExprSyntax*, DelayedSequenceExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DescendingRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableConstraintSyntax*, DisableConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableForkStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableForkStatementSyntax*, DisableForkStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableIff: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableIffSyntax*, DisableIffSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableStatementSyntax*, DisableStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DistConstraintList: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistConstraintListSyntax*, DistConstraintListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DistItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistItemSyntax*, DistItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DistWeight: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistWeightSyntax*, DistWeightSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DivideAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DivideExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DividerClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const DividerClauseSyntax*, DividerClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DoWhileStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DoWhileStatementSyntax*, DoWhileStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DotMemberClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const DotMemberClauseSyntax*, DotMemberClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DriveStrength: return visitor.visit(*static_cast<std::conditional_t<isConst, const DriveStrengthSyntax*, DriveStrengthSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EdgeControlSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const EdgeControlSpecifierSyntax*, EdgeControlSpecifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EdgeDescriptor: return visitor.visit(*static_cast<std::conditional_t<isConst, const EdgeDescriptorSyntax*, EdgeDescriptorSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EdgeSensitivePathSuffix: return visitor.visit(*static_cast<std::conditional_t<isConst, const EdgeSensitivePathSuffixSyntax*, EdgeSensitivePathSuffixSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElabSystemTask: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElabSystemTaskSyntax*, ElabSystemTaskSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElementSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElementSelectSyntax*, ElementSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElementSelectExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElementSelectExpressionSyntax*, ElementSelectExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElsIfDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElseClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElseClauseSyntax*, ElseClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElseConstraintClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElseConstraintClauseSyntax*, ElseConstraintClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElseDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconditionalBranchDirectiveSyntax*, UnconditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElsePropertyClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElsePropertyClauseSyntax*, ElsePropertyClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyArgumentSyntax*, EmptyArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyIdentifierName: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyIdentifierNameSyntax*, EmptyIdentifierNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyMemberSyntax*, EmptyMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyNonAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyNonAnsiPortSyntax*, EmptyNonAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyPortConnectionSyntax*, EmptyPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyQueueExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyQueueExpressionSyntax*, EmptyQueueExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyStatementSyntax*, EmptyStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyTimingCheckArg: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyTimingCheckArgSyntax*, EmptyTimingCheckArgSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EndCellDefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EndIfDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconditionalBranchDirectiveSyntax*, UnconditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EndKeywordsDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EndProtectDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EndProtectedDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EnumType: return visitor.visit(*static_cast<std::conditional_t<isConst, const EnumTypeSyntax*, EnumTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EqualsAssertionArgClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const EqualsAssertionArgClauseSyntax*, EqualsAssertionArgClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EqualsTypeClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const EqualsTypeClauseSyntax*, EqualsTypeClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EqualsValueClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const EqualsValueClauseSyntax*, EqualsValueClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventControlSyntax*, EventControlSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EventControlWithExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventControlWithExpressionSyntax*, EventControlWithExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EventType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpectPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExplicitAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExplicitAnsiPortSyntax*, ExplicitAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExplicitNonAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExplicitNonAnsiPortSyntax*, ExplicitNonAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionConstraintSyntax*, ExpressionConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionCoverageBinInitializerSyntax*, ExpressionCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionOrDist: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionOrDistSyntax*, ExpressionOrDistSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionPatternSyntax*, ExpressionPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionStatementSyntax*, ExpressionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionTimingCheckArg: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionTimingCheckArgSyntax*, ExpressionTimingCheckArgSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExtendsClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExtendsClauseSyntax*, ExtendsClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExternInterfaceMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExternInterfaceMethodSyntax*, ExternInterfaceMethodSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExternModuleDecl: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExternModuleDeclSyntax*, ExternModuleDeclSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExternUdpDecl: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExternUdpDeclSyntax*, ExternUdpDeclSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FilePathSpec: return visitor.visit(*static_cast<std::conditional_t<isConst, const FilePathSpecSyntax*, FilePathSpecSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FinalBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FirstMatchSequenceExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const FirstMatchSequenceExprSyntax*, FirstMatchSequenceExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FollowedByPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryPropertyExprSyntax*, BinaryPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForLoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForLoopStatementSyntax*, ForLoopStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForVariableDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForVariableDeclarationSyntax*, ForVariableDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForeachLoopList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeachLoopListSyntax*, ForeachLoopListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForeachLoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeachLoopStatementSyntax*, ForeachLoopStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForeverStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeverStatementSyntax*, ForeverStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForwardTypeRestriction: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForwardTypeRestrictionSyntax*, ForwardTypeRestrictionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForwardTypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForwardTypedefDeclarationSyntax*, ForwardTypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionDeclarationSyntax*, FunctionDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPortSyntax*, FunctionPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPortListSyntax*, FunctionPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPrototypeSyntax*, FunctionPrototypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GenerateBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenerateBlockSyntax*, GenerateBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GenerateRegion: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenerateRegionSyntax*, GenerateRegionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GenvarDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenvarDeclarationSyntax*, GenvarDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GreaterThanEqualExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GreaterThanExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::HierarchicalInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const HierarchicalInstanceSyntax*, HierarchicalInstanceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::HierarchyInstantiation: return visitor.visit(*static_cast<std::conditional_t<isConst, const HierarchyInstantiationSyntax*, HierarchyInstantiationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IdWithExprCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdWithExprCoverageBinInitializerSyntax*, IdWithExprCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IdentifierName: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierNameSyntax*, IdentifierNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IdentifierSelectName: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierSelectNameSyntax*, IdentifierSelectNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IfDefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IfGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const IfGenerateSyntax*, IfGenerateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IfNDefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IfNonePathDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const IfNonePathDeclarationSyntax*, IfNonePathDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IffEventClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const IffEventClauseSyntax*, IffEventClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IffPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryPropertyExprSyntax*, BinaryPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateAssertStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateAssertionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionMemberSyntax*, ImmediateAssertionMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateAssumeStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateCoverStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplementsClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplementsClauseSyntax*, ImplementsClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicationConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicationConstraintSyntax*, ImplicationConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicationPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryPropertyExprSyntax*, BinaryPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitAnsiPortSyntax*, ImplicitAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitEventControlSyntax*, ImplicitEventControlSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitNonAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitNonAnsiPortSyntax*, ImplicitNonAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitType: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitTypeSyntax*, ImplicitTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImpliesPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryPropertyExprSyntax*, BinaryPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IncludeDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const IncludeDirectiveSyntax*, IncludeDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InitialBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InsideExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const InsideExpressionSyntax*, InsideExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InstanceConfigRule: return visitor.visit(*static_cast<std::conditional_t<isConst, const InstanceConfigRuleSyntax*, InstanceConfigRuleSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InstanceName: return visitor.visit(*static_cast<std::conditional_t<isConst, const InstanceNameSyntax*, InstanceNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntegerLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntegerType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntegerVectorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerVectorExpressionSyntax*, IntegerVectorExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InterfaceDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InterfaceHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InterfacePortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const InterfacePortHeaderSyntax*, InterfacePortHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntersectClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntersectClauseSyntax*, IntersectClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntersectSequenceExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinarySequenceExprSyntax*, BinarySequenceExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InvocationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const InvocationExpressionSyntax*, InvocationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::JumpStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const JumpStatementSyntax*, JumpStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LessThanEqualExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LessThanExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const LetDeclarationSyntax*, LetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LibraryDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const LibraryDeclarationSyntax*, LibraryDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LibraryIncDirClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const LibraryIncDirClauseSyntax*, LibraryIncDirClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LibraryIncludeStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const LibraryIncludeStatementSyntax*, LibraryIncludeStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LibraryMap: return visitor.visit(*static_cast<std::conditional_t<isConst, const LibraryMapSyntax*, LibraryMapSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const LineDirectiveSyntax*, LineDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LocalScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LocalVariableDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const LocalVariableDeclarationSyntax*, LocalVariableDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalEquivalenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalImplicationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalLeftShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalRightShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalShiftLeftExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalShiftRightExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LongIntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LoopConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopConstraintSyntax*, LoopConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LoopGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopGenerateSyntax*, LoopGenerateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopStatementSyntax*, LoopStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroActualArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroActualArgumentSyntax*, MacroActualArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroActualArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroActualArgumentListSyntax*, MacroActualArgumentListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroArgumentDefault: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroArgumentDefaultSyntax*, MacroArgumentDefaultSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroFormalArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroFormalArgumentSyntax*, MacroFormalArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroFormalArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroFormalArgumentListSyntax*, MacroFormalArgumentListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroUsage: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroUsageSyntax*, MacroUsageSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MatchesClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const MatchesClauseSyntax*, MatchesClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MemberAccessExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MemberAccessExpressionSyntax*, MemberAccessExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MinTypMaxExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MinTypMaxExpressionSyntax*, MinTypMaxExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportClockingPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportClockingPortSyntax*, ModportClockingPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportDeclarationSyntax*, ModportDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportExplicitPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportExplicitPortSyntax*, ModportExplicitPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportItemSyntax*, ModportItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportNamedPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportNamedPortSyntax*, ModportNamedPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportSimplePortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSimplePortListSyntax*, ModportSimplePortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportSubroutinePort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSubroutinePortSyntax*, ModportSubroutinePortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportSubroutinePortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSubroutinePortListSyntax*, ModportSubroutinePortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModuleDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModuleHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MultipleConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MultipleConcatenationExpressionSyntax*, MultipleConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MultiplyAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MultiplyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NameValuePragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NameValuePragmaExpressionSyntax*, NameValuePragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedArgumentSyntax*, NamedArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedBlockClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedBlockClauseSyntax*, NamedBlockClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedConditionalDirectiveExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedConditionalDirectiveExpressionSyntax*, NamedConditionalDirectiveExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedLabel: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedLabelSyntax*, NamedLabelSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedParamAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedParamAssignmentSyntax*, NamedParamAssignmentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedPortConnectionSyntax*, NamedPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedStructurePatternMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedStructurePatternMemberSyntax*, NamedStructurePatternMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedType: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedTypeSyntax*, NamedTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NetAlias: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetAliasSyntax*, NetAliasSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetDeclarationSyntax*, NetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NetPortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetPortHeaderSyntax*, NetPortHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NetTypeDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetTypeDeclarationSyntax*, NetTypeDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NewArrayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewArrayExpressionSyntax*, NewArrayExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NewClassExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewClassExpressionSyntax*, NewClassExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NoUnconnectedDriveDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonAnsiPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const NonAnsiPortListSyntax*, NonAnsiPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonAnsiUdpPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const NonAnsiUdpPortListSyntax*, NonAnsiUdpPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonblockingAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonblockingEventTriggerStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventTriggerStatementSyntax*, EventTriggerStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NullLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NumberPragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NumberPragmaExpressionSyntax*, NumberPragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OneStepDelay: return visitor.visit(*static_cast<std::conditional_t<isConst, const OneStepDelaySyntax*, OneStepDelaySyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryPropertyExprSyntax*, BinaryPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrSequenceExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinarySequenceExprSyntax*, BinarySequenceExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrderedArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedArgumentSyntax*, OrderedArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrderedParamAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedParamAssignmentSyntax*, OrderedParamAssignmentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrderedPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedPortConnectionSyntax*, OrderedPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrderedStructurePatternMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedStructurePatternMemberSyntax*, OrderedStructurePatternMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageExportAllDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageExportAllDeclarationSyntax*, PackageExportAllDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageExportDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageExportDeclarationSyntax*, PackageExportDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageImportDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageImportDeclarationSyntax*, PackageImportDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageImportItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageImportItemSyntax*, PackageImportItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParallelBlockStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockStatementSyntax*, BlockStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterDeclarationSyntax*, ParameterDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterDeclarationStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterDeclarationStatementSyntax*, ParameterDeclarationStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterPortListSyntax*, ParameterPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterValueAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterValueAssignmentSyntax*, ParameterValueAssignmentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenExpressionList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenExpressionListSyntax*, ParenExpressionListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenPragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenPragmaExpressionSyntax*, ParenPragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenthesizedBinsSelectExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedBinsSelectExprSyntax*, ParenthesizedBinsSelectExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenthesizedConditionalDirectiveExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedConditionalDirectiveExpressionSyntax*, ParenthesizedConditionalDirectiveExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenthesizedEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedEventExpressionSyntax*, ParenthesizedEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenthesizedExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedExpressionSyntax*, ParenthesizedExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenthesizedPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedPatternSyntax*, ParenthesizedPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenthesizedPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedPropertyExprSyntax*, ParenthesizedPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenthesizedSequenceExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedSequenceExprSyntax*, ParenthesizedSequenceExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PathDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PathDeclarationSyntax*, PathDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PathDescription: return visitor.visit(*static_cast<std::conditional_t<isConst, const PathDescriptionSyntax*, PathDescriptionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PatternCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const PatternCaseItemSyntax*, PatternCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PortConcatenation: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortConcatenationSyntax*, PortConcatenationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PortDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortDeclarationSyntax*, PortDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PortReference: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortReferenceSyntax*, PortReferenceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PostdecrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PostfixUnaryExpressionSyntax*, PostfixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PostincrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PostfixUnaryExpressionSyntax*, PostfixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PowerExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PragmaDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const PragmaDirectiveSyntax*, PragmaDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PrimaryBlockEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrimaryBlockEventExpressionSyntax*, PrimaryBlockEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PrimitiveInstantiation: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrimitiveInstantiationSyntax*, PrimitiveInstantiationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralAssignStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralAssignStatementSyntax*, ProceduralAssignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralDeassignStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralDeassignStatementSyntax*, ProceduralDeassignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralForceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralAssignStatementSyntax*, ProceduralAssignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralReleaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralDeassignStatementSyntax*, ProceduralDeassignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::Production: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProductionSyntax*, ProductionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProgramDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProgramHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PropertyDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PropertyDeclarationSyntax*, PropertyDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PropertySpec: return visitor.visit(*static_cast<std::conditional_t<isConst, const PropertySpecSyntax*, PropertySpecSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PropertyType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProtectDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProtectedDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PullStrength: return visitor.visit(*static_cast<std::conditional_t<isConst, const PullStrengthSyntax*, PullStrengthSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PulseStyleDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PulseStyleDeclarationSyntax*, PulseStyleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::QueueDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const QueueDimensionSpecifierSyntax*, QueueDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RandCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandCaseItemSyntax*, RandCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RandCaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandCaseStatementSyntax*, RandCaseStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RandJoinClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandJoinClauseSyntax*, RandJoinClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RandSequenceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandSequenceStatementSyntax*, RandSequenceStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RangeCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeCoverageBinInitializerSyntax*, RangeCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RangeDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeDimensionSpecifierSyntax*, RangeDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RangeList: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeListSyntax*, RangeListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RealLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RealTimeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RealType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RegType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RepeatedEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const RepeatedEventControlSyntax*, RepeatedEventControlSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ReplicatedAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ReplicatedAssignmentPatternSyntax*, ReplicatedAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ResetAllDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RestrictPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ReturnStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ReturnStatementSyntax*, ReturnStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RootScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RsCase: return visitor.visit(*static_cast<std::conditional_t<isConst, const RsCaseSyntax*, RsCaseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RsCodeBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const RsCodeBlockSyntax*, RsCodeBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RsElseClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const RsElseClauseSyntax*, RsElseClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RsIfElse: return visitor.visit(*static_cast<std::conditional_t<isConst, const RsIfElseSyntax*, RsIfElseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RsProdItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const RsProdItemSyntax*, RsProdItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RsRepeat: return visitor.visit(*static_cast<std::conditional_t<isConst, const RsRepeatSyntax*, RsRepeatSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RsRule: return visitor.visit(*static_cast<std::conditional_t<isConst, const RsRuleSyntax*, RsRuleSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RsWeightClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const RsWeightClauseSyntax*, RsWeightClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SUntilPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryPropertyExprSyntax*, BinaryPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SUntilWithPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryPropertyExprSyntax*, BinaryPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ScopedName: return visitor.visit(*static_cast<std::conditional_t<isConst, const ScopedNameSyntax*, ScopedNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SequenceDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const SequenceDeclarationSyntax*, SequenceDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SequenceMatchList: return visitor.visit(*static_cast<std::conditional_t<isConst, const SequenceMatchListSyntax*, SequenceMatchListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SequenceRepetition: return visitor.visit(*static_cast<std::conditional_t<isConst, const SequenceRepetitionSyntax*, SequenceRepetitionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SequenceType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SequentialBlockStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockStatementSyntax*, BlockStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ShortIntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ShortRealType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SignalEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SignalEventExpressionSyntax*, SignalEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SignedCastExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SignedCastExpressionSyntax*, SignedCastExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SimpleAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleAssignmentPatternSyntax*, SimpleAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SimpleBinsSelectExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleBinsSelectExprSyntax*, SimpleBinsSelectExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SimplePathSuffix: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimplePathSuffixSyntax*, SimplePathSuffixSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SimplePragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimplePragmaExpressionSyntax*, SimplePragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SimplePropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimplePropertyExprSyntax*, SimplePropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SimpleRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SimpleSequenceExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleSequenceExprSyntax*, SimpleSequenceExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SolveBeforeConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const SolveBeforeConstraintSyntax*, SolveBeforeConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SpecifyBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const SpecifyBlockSyntax*, SpecifyBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SpecparamDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const SpecparamDeclarationSyntax*, SpecparamDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SpecparamDeclarator: return visitor.visit(*static_cast<std::conditional_t<isConst, const SpecparamDeclaratorSyntax*, SpecparamDeclaratorSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StandardCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const StandardCaseItemSyntax*, StandardCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StandardPropertyCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const StandardPropertyCaseItemSyntax*, StandardPropertyCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StandardRsCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const StandardRsCaseItemSyntax*, StandardRsCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StreamExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamExpressionSyntax*, StreamExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StreamExpressionWithRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamExpressionWithRangeSyntax*, StreamExpressionWithRangeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StreamingConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamingConcatenationExpressionSyntax*, StreamingConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StringLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StringType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StrongWeakPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const StrongWeakPropertyExprSyntax*, StrongWeakPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructType: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionTypeSyntax*, StructUnionTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructUnionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionMemberSyntax*, StructUnionMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructurePattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructurePatternSyntax*, StructurePatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructuredAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructuredAssignmentPatternSyntax*, StructuredAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SubtractAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SubtractExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SuperHandle: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SuperNewDefaultedArgsExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SuperNewDefaultedArgsExpressionSyntax*, SuperNewDefaultedArgsExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SystemName: return visitor.visit(*static_cast<std::conditional_t<isConst, const SystemNameSyntax*, SystemNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SystemTimingCheck: return visitor.visit(*static_cast<std::conditional_t<isConst, const SystemTimingCheckSyntax*, SystemTimingCheckSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TaggedPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const TaggedPatternSyntax*, TaggedPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TaggedUnionExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const TaggedUnionExpressionSyntax*, TaggedUnionExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TaskDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionDeclarationSyntax*, FunctionDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ThisHandle: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ThroughoutSequenceExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinarySequenceExprSyntax*, BinarySequenceExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimeLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimeScaleDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimeScaleDirectiveSyntax*, TimeScaleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimeUnitsDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimeUnitsDeclarationSyntax*, TimeUnitsDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimingCheckEventArg: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingCheckEventArgSyntax*, TimingCheckEventArgSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimingCheckEventCondition: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingCheckEventConditionSyntax*, TimingCheckEventConditionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimingControlExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlExpressionSyntax*, TimingControlExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimingControlStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlStatementSyntax*, TimingControlStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransListCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransListCoverageBinInitializerSyntax*, TransListCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransRangeSyntax*, TransRangeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransRepeatRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransRepeatRangeSyntax*, TransRepeatRangeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransSet: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransSetSyntax*, TransSetSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TypeAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypeAssignmentSyntax*, TypeAssignmentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TypeParameterDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypeParameterDeclarationSyntax*, TypeParameterDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TypeReference: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypeReferenceSyntax*, TypeReferenceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypedefDeclarationSyntax*, TypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UdpBody: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpBodySyntax*, UdpBodySyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UdpDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpDeclarationSyntax*, UdpDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UdpEdgeField: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpEdgeFieldSyntax*, UdpEdgeFieldSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UdpEntry: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpEntrySyntax*, UdpEntrySyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UdpInitialStmt: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpInitialStmtSyntax*, UdpInitialStmtSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UdpInputPortDecl: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpInputPortDeclSyntax*, UdpInputPortDeclSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UdpOutputPortDecl: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpOutputPortDeclSyntax*, UdpOutputPortDeclSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UdpSimpleField: return visitor.visit(*static_cast<std::conditional_t<isConst, const UdpSimpleFieldSyntax*, UdpSimpleFieldSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBinsSelectExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnaryBinsSelectExprSyntax*, UnaryBinsSelectExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseNandExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseNorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseNotExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseXnorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseXorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryConditionalDirectiveExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnaryConditionalDirectiveExpressionSyntax*, UnaryConditionalDirectiveExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryLogicalNotExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryMinusExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryPlusExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryPredecrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryPreincrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnaryPropertyExprSyntax*, UnaryPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnarySelectPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnarySelectPropertyExprSyntax*, UnarySelectPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnbasedUnsizedLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnconnectedDriveDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconnectedDriveDirectiveSyntax*, UnconnectedDriveDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UndefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UndefDirectiveSyntax*, UndefDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UndefineAllDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnionType: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionTypeSyntax*, StructUnionTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UniquenessConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const UniquenessConstraintSyntax*, UniquenessConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnitScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UntilPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryPropertyExprSyntax*, BinaryPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UntilWithPropertyExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryPropertyExprSyntax*, BinaryPropertyExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::Untyped: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UserDefinedNetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const UserDefinedNetDeclarationSyntax*, UserDefinedNetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ValueRangeExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ValueRangeExpressionSyntax*, ValueRangeExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VariableDimension: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariableDimensionSyntax*, VariableDimensionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VariablePattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariablePatternSyntax*, VariablePatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VariablePortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariablePortHeaderSyntax*, VariablePortHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VirtualInterfaceType: return visitor.visit(*static_cast<std::conditional_t<isConst, const VirtualInterfaceTypeSyntax*, VirtualInterfaceTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VoidCastedCallStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const VoidCastedCallStatementSyntax*, VoidCastedCallStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VoidType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WaitForkStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitForkStatementSyntax*, WaitForkStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WaitOrderStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitOrderStatementSyntax*, WaitOrderStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WaitStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitStatementSyntax*, WaitStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardDimensionSpecifierSyntax*, WildcardDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardEqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardInequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPatternSyntax*, WildcardPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPortConnectionSyntax*, WildcardPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPortListSyntax*, WildcardPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardUdpPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardUdpPortListSyntax*, WildcardUdpPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WithClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithClauseSyntax*, WithClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WithFunctionClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithFunctionClauseSyntax*, WithFunctionClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WithFunctionSample: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithFunctionSampleSyntax*, WithFunctionSampleSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WithinSequenceExpr: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinarySequenceExprSyntax*, BinarySequenceExprSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::XorAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
    }
    SLANG_UNREACHABLE;
}

}

template<typename TVisitor, typename... Args>
decltype(auto) SyntaxNode::visit(TVisitor& visitor, Args&&... args) {
    return detail::visitSyntaxNode(this, visitor, std::forward<Args>(args)...);
}

template<typename TVisitor, typename... Args>
decltype(auto) SyntaxNode::visit(TVisitor& visitor, Args&&... args) const {
    return detail::visitSyntaxNode(this, visitor, std::forward<Args>(args)...);
}

}
